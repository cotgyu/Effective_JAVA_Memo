이펙티브 자바
-------------

---

### 12장 직렬화

-	객체 직렬화란 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트릠으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘이다.
	-	직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역직렬화할 수 있다.

#### 아이템 85 자바 직렬화의 대안을 찾으라

-	직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다.

	-	ObjectInputStream의 readObject 메서드를 호출하면서 객체 그래프가 역직렬화되기 때문
	-	readObject 메서드는 Serializable 인터페이스를 구현했다면 클래스패스 안의 거의 모든 타입의 객체를 만들어낼 수 있는 생성자
	-	바이트 스트림을 역직렬화하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 모두 수행할 수 있다. (그 타입들의 모드 전체가 공격범위에 들어감)

-	역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있음 (역직렬화 폭탄)

> 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.

-	객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이 있다.

	-	이 방식들은 자바 직렬화의 여러 위험을 회피하면서 다양한 플랫폼 지원, 우수한 성능, 풍부한 지원 도구, 활발한 커뮤니티와 전문가 집단 등 수많은 이점까지 제공한다.
	-	이러한 메커니즘도 직렬화 시스템이라 불리기도 하지만, 책에선 구분하고자 크로스-플랫폼 구조화된 데이터 표현이라 함
	-	이런 표현들의 공통점은 자바 직렬화보다 훨씬 간단함.
		-	임의 객체 그래프를 자동으로 직렬화/역직렬화하지 않는다.
		-	대신 속성 값-쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용한다.
	-	크로스-플랫폼 구조화된 데이터 포현의 선두주자는 JSON과 프로토콜 버퍼임

-	레거시 시스템 떄문에 자바 직렬화를 완전히 배제할 수 없을 때의 차선책은 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다.

-	직렬화를 피할 수 없고 역직렬화된 데이터가 안전한지 완전히 확신할 수 없다면 객체 역직렬화 필러링을 사용하자 (자바 9)

	-	데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능
	-	클래스 단위로, 특정 클래스를 받아들이거나 거부할 수 있음

-	책에 있는 핵심 정리

	-	직렬화는 위험하니 피해야 한다.
	-	시스템을 밑바닥부터 설계한다면 JSON이나 프로톸콜 버퍼 같은 대안을 사용하자.
	-	신뢰할 수 없는 데이터는 역직렬화하지 말자.
	-	꼭 해야한다면 객체 역직렬화 필터링을 사용하되, 이마저도 모든 공격을 막아줄 수는 없음을 기억하자.
	-	클래스가 직렬화를 지원하도록 만들지 말고, 꼭 그렇게 만들어야 한다면 정말 신경써서 작성해야 한다.

#### 아이템 86 Serializable을 구현할지는 신중히 결정하라

-	클래스의 인스턴스를 직렬화할 수 있게 하려면 클래스 선언에 implements Serializable 만 덧붙이면 된다.

	-	쉽게 적용할 수 있지만 신경쓸게 많다.

-	Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.

	-	클래스가 Serializable을 구현하면 직렬화된 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 API가 된다.
	-	그래서 이 클래스가 널리 퍼진다면 그 직렬화 형태도 영원히 지원해야 한다.
	-	커스텀 직렬화 형태를 설계하지 않고 자바의 기본 방식을 사용하면 직렬화 형태는 최소 적용 당시 클래스의 내부 구현 방식에 영원히 묶여버린다.
		-	기본 직렬화 형태에서는 클래스의 private 과 package-private 인스턴스 필드마저 API로 공개된다

-	직렬화 가능 클래스를 만들고자 한다면, 길게 보고 감당할 수 있을 만큼 고품질의 직렬화 형태도 주의해서 함께 설계해야 한다.

-	직렬화가 클래스 개선을 방해하는 예

	-	모든 직렬화 클래스는 고유 식별 번호를 부여받는다. serialVersionUID

		-	명시하지 않으면 시스템이 런타임에 암호해시 함수를 적용해 자동으로 넣음
		-	이 값은 클래스이름, 구현한 인터페이스들 등이 고려되는데 나중에 편의 메서드를 추가하는 식으로 이들 중 하나라도 수정되면 직렬 버전 UID도 변경함
		-	쉽게 호환성이 깨져 런타임에 InvaildClassException이 발생할 수 있음

	-	버그와 보안 구멍이 생길 위험이 높아짐

		-	직렬화는 언어의 기본 메커니즘을 우회하는 객체 생성 기법임
		-	기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출됨

	-	해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어남

		-	직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지 그리고, 그 반대도 가능한지를 검사해야 한다.
		-	양방향 직렬화/역직렬화가 모두 성공하고 원래의 객체를 충실히 복제해내는지를 반드시 확인해야함

-	상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 ㅂ대부분 Serializable을 확장해서는 안된다.

-	클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하다면 주의해야할 점이 몇가지 있음

	-	인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 해야 한다.

		-	finalize 메서드를 자신이 재정의하면서 final 로 선언하면 됨
		-	이렇게 해두지 않으면 finalizer 공격을 당할 수 있음

	-	인스턴스 필드 중 기본 값으로 초기화되면 위배되는 불변식이 있다면 클래스에 다음의 readObjectNodata 메서드를 반드시 추가해야한다.

		```java
		private void readObjectNoData() throws InvalidObjectException {
		    throw new InvaildObjectException("스트림 데이터가 필요합니다.");
		}
		```

-	내부 클래스는 직렬화를 구현하지 말아야 한다.

	-	내부 클래스에 대한 기본 직렬화 형태는 분명하지가 않다.

-	책에 있는 핵심 정리

	-	Serializable은 구현한다고 선언하기는 아주 쉽지만, 그것은 눈속임일 뿐이다.
	-	한 클래스의 여러 버전이 상호작용할 일이 없고 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등, 보호된 환경에서만 쓰일 클래스가 아니라면 Serializable 구현은 아주 신중하게 이뤄져야 한다.
	-	상속할 수 있는 클래스라면 주의사항이 더욱 많아진다.
