이펙티브 자바
-------------

---

### 8장 메서드

-	메서드를 설계할 때 주의할 점들을 살펴본다.

#### 아이템 49 매개변수가 유효한지 검사하라

-	메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. (음수 X, null X 등)

	-	이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다.

	-	오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생지점을 찾기 어려워진다.

-	메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.

	-	매개변수 검사를 제대로 하지못할 경우 생기는 문제
		-	메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
		-	메서드는 문제없이 실행되었지만 잘못된 결과를 반환할 수 있다. 이 결과로 알 수 없는 문제 발생가능

-	public 과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.

-	자바7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.

```java
this.strategy = Objects.requireNonNill(strategy, "전략");
```

-	생성자의 매개변수 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.

-	예외는 있다.

	-	유효성 검사비용이 지나치게 높거나 실용적이지 않을 때
	-	계산과정에서 암묵적으로 검사가 수행될 때

-	메서드는 최대한 범용적으로 설계해야 한다.

	-	메서드가 건네 받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을 수록 좋다.
	-	하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우 검사가 필요하다.

-	책에 있는 핵심 정리

	-	메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야한다.
	-	그 제약들을 문서화하고 메서드 코드 시작부분에서 명시적으로 검사해야 한다.

#### 아이템 50 적시에 방어적 복사본을 만들라

-	자바는 안전한 언어다.

	-	네이티브 메서드를 사용하지 않으니, C, C++ 같이 안전하지 않은 언어에서 흔히 보는 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다.

-	하지만, 다른 클래스로부터의 침범을 아무런 노력없이 다 막을 수 없는 건 아니다.

	-	따라서 클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍 해야한다.

```java
public final class Period {
	private final Date start;
	private final Data end;

	public Period(Date start, Date end){
		if(start.compareTo(end) > 0){
			throw new IllegalArgumentException();
		}

		this.start = start;
		this.end = end;
	}

	public Data start(){
		return start;
	}

	public Date end(){
		return end;
	}
	...
}

// Date가 가변이라는 사실을 이용하여 Period 인스턴스 내부 공격
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p 내부 수정하기
```

-	Date 대신 불변인 Instant 를 사용하면 위의 공격을 방지할 수 있다. (LocalDateTime 이나 ZoneDateTime 사용가능)

	-	Date는 낡은 API이니 새로운 코드를 작성할 때는 더 이상 사용하면 안된다.

-	외부 공격으로부터 Period 인스턴스의 내부를 보호하려면 생성자에게서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.

```java
// 매개변수의 유효성 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성 검사한 예시
public Period(Date start, Date end){

	this.start = new Date(start.getTime());
	this.end = new Date(end.getTime());

	if(this.start.compareTo(this.end) > 0){
		throw new IllegalArgumentException();
	}

}
```

-	멀티스레딩 환경이라면 원본 객체의 유효성 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있으니 위와 같이 작성해야한다. (검사시점/사용 시점 공격)

-	방어적 복사에 Date의 clone 메서드를 사용하지 않는다.

	-	Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수 있다. (이 하위클래스는 start와 end 필드의 참조를 private 정적 리스트에 담아뒀다가 공격자에게 이 리스트를 접근하는 길을 열어 줄 수 있음)

	-	매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안된다.

-	Period 인스턴스는 아직 변경이 가능하다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78); // p 내부 수정하기
```

-	가변필드의 방어적 복사본을 반환하자.

```java
public Data start(){
	return new Date(start.getTime());
}

public Date end(){
	return new Date(end.getTime());
}
```

-	매개변수를 방어적으로 복사하는 목적이 불변객체를 만들기 위해서만은 아니다.

	-	메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야한다.
	-	변경할 수 없어야한다면 방어적본사본을 활용하자.

-	방어적 복사에는 성능 저하가 따르고, 항상 쓸 수 있는 것도 아니다.

	-	호출자가 컴포넌트 내부를 수정하지 않으리라 확실하면 방어적 복사를 생략할 수 있다. (이 상황에도 호출자에서 해당 매개변수나 반환 값을 수정하지 말아야 함을 명확히 문서화하는 게 좋다.)

-	통제권을 넘겨받기로 한 메서드나 생성자를 가진 클래스들은 악의적인 클라이언트의 공격에 취약하다.

	-	방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때, 혹은 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 떄로 한정해야 한다.

-	책에 있는 핵심 정리

	-	클래스가 클라이언트로부터 받은 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
	-	복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하자.

#### 아이템 51 메서드 시그니처를 신중히 설계하라

-	API 설계요령을 설명한다.

-	메서드 이름을 신중히 짓자.

	-	이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는게 최우선 목표이다.
	-	긴 이름은 피하자.
	-	애매하면 자바 라이브러리의 API 가이드를 참조하라.

-	편의 메서드를 너무 많이 만들지 말자.

	-	메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다. (인터페이스도 마찬가지)
	-	아주 자주 쓰일 경우에만 별도의 약칭 메서드를 두자.
	-	확신히 서지 않으면 만들지 말자.

-	매개변수 목록은 짧게 유지히자.

	-	4개 이하가 좋음.
	-	같은 타입의 매개변수 여러 개가 연달아 나오는 경우는 특히 해롭다. (실수가 생길 수 있음)
	-	매개변수 목록을 줄여주는 방법

		-	여러 메서드로 쪼개기
		-	매개변수 여러 개를 묶어주는 도우미 클래스 만들기
		-	두 기법 혼합 (객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용하기)

	-	매개변수의 타입으로는 클래스보다는 인터페이스가 낫다.

		-	매개변수로 적합한 인터페이스가 있다면 그 인터페이스를 직접 사용하자.
		-	ex_ HashMap 말고 Map을 사용하자. (HashMap 뿐만 아니라 TreeMap, ConcurrentHashMap 등을 인수로 건넬 수 있다.)
		-	인터페이스 대신 클래스를 사용하면 클라이언트에게 특정 구현체만 사용하도록 제한하는 꼴이며, 혹시라도 입력 데이터가 다른 형태로 존재한다면 명시한 특정 구현체의 객체로 옮겨 담느라 비싼 복사비용을 지불해야한다.
		-	boolean 보다는 원소 2개짜리 열거 타입이 낫다.

#### 아이템 52 다중정의는 신중히 사용하라

-	재정의한 매서드는 동적으로 선택되고, 다중 정의한 메서드는 정적으로 선택된다.

	-	메서드를 재정의했다면 해당 객체의 런타임 타입이 어떤 메서드를 호출할지의 기준이 된다.
	-	메서드를 재정의한 다음 '하위 클래스의 인스턴스'에서 그 메서드를 호출하면 재정의한 메서드가 실행된다.
	-	다중정의된 메서드 사이에서는 객체의 런타임 타입은 전혀 중요치 않다. 오직 매개변수의 컴파일 타입에 의해 이뤄진다.

-	다중정의가 혼동을 일으키는 상황을 피해야 한다.

	-	API사용자가 매개변수를 넘기면서 어떤 다중정의 메서드가 호출될지를 모르다면 프로그램이 오동작하기 쉽다.
	-	안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.
	-	다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 열려있다.

-	메서드를 다중정의할 때, 사로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다.

-	책에 있는 핵심 정리

	-	프로그래밍 언어가 다중정의를 허용한다고 해서 다중 정의를 꼭 활용하란 뜻은 아니다.
	-	일반적으로 매개변수 수가 같을 때는 다중정의를 피하는 것이 좋다.
	-	상황에 따라, 특히 생성자라면 이 조언을 따르기가 불가능할 수 있다. 그럴 떄는 헷갈릴 만한 매개변수는 형변환하여 정확한 다중정의 메서드가 선택되도록 해야 한다.

		-	이것이 불가능하다면 (기존 클래스를 수정해 새로운 인터페이스를 구현해야 할 때) 같은 객체를 입력받는 다중 정의 메서드들이 모두 동일하게 동작하도록 만들어야 한다.

		-	그렇지 못하면 프로그래머들은 다중정의된 메서드나 생성자를 효과적으로 사용하지 못할 것이고, 의도대로 동작하지 않는 이유를 이해하지 못할 것이다.

#### 아이템 53 가변인수는 신중히 사용하라

-	가변인수 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있다.

-	가변인수 메서드를 호출하면, 가장 먼저 인수의 개수와 길이가 같은 배열을 만들고 인수들을 이 배열에서 저장하여 가변인수 메서드에 건네준다.

```java
static int sum(int... args){
	int sum = 0;
	for(int arg : args){
		sum += arg;
	}
	return sum;
}

// 인수가 1개 이상이어야할 때 가변인수를 제대로 사용하는 방법
static int min(int firstArg, int... remainingArgs){
	int mim = firstArg;
	for(int arg : remainingArgs){
		if (arg < min){
			min = arg;
		}
		return min;
	}
}
```

-	가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화된다. 성능에 민감한 상황인 경우 가변인수가 걸림돌이 될 수 있음

	-	인수가 0개인 것부터 n개 인것까지 다중 정의하여 해소할 수 있다.

-	책에 있는 핵심 정리

	-	인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다.
	-	메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려하자.

#### 아이템 54 null이 아닌, 빈 컬렉션이나 배열을 반환하라

-	컬렉션이나 배열 같은 컨테이너가 비었을 때 null을 반환하는 메서드를 사용할 때면 항시 방어 코드를 넣어줘야한다.

> 클라이언트에서 방어코드를 뺴먹으면 오류가 발생할 수 있다.

-	빈 컨테이너 할당에도 비용이 드니 null을 반환하는 것이 낫다는 주장도 있지만 두 가지면에서 틀리다고 한다.

	-	이 정도 성능 차이는 신경 쓸 수준이 못된다.
	-	빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.

		```java
		public List<Cheese> getCheese(){
		    return new ArrayList<>(cheeseInStock);
		}
		```

	-	가능성은 작지만, 사용 패턴에 따라 빈 컬렉션 할당이 성능을 눈에 띄게 떨어뜨릴 수 있다.

		-	해법은 매번 똑같은 빈 불변 컬렉션을 반환하는 것이다. (Collections.emptyList(), Collections.emptySet(), Collections.emptyMap() )

			```java
			public List<Cheese> getCheese(){
			    return cheeseInStock.isEmpty() ? Collections.emptyList() : new ArrayList<>(cheeseInStock);
			}
			```

		-	배열은 길이가 0인 배열을 반환하라. 혹은 길이가 0짜리 배열을 미리 선언해두고 매번 그 배열을 반환하라

			```java
			public Cheese[] getCheese() {
			    return cheeseInStock.toArray(new Cheese[0]);
			}


			// 길이가 0인 배열 미리 선언
			private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];


			public Cheese[] getCheese(){
			    return cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);
			}
			```

-	단순히 성능을 개선할 목적이라면 toArray에 넘기는 배열을 미리 할당하는 건 추천하지 않는다. 오히려 성능을 떨어뜨린다는 연구 결과도 있다.

	```java
	return cheeseInStock.toArray(new Cheese[cheeseInStock.size()]);
	```

-	책에 있는 핵심 정리

	-	null이 아닌, 빈 배열이나 컬렉션을 반환하라.
	-	null을 반환하는 API는 사용하기 어렵고 오류처리 코드도 늘어난다. 그렇다고 성능이 좋은 것도 아니다.
