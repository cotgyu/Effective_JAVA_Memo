이펙티브 자바
-------------

---

### 8장 메서드

-	메서드를 설계할 때 주의할 점들을 살펴본다.

#### 아이템 49 매개변수가 유효한지 검사하라

-	메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. (음수 X, null X 등)

	-	이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다.

	-	오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생지점을 찾기 어려워진다.

-	메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.

	-	매개변수 검사를 제대로 하지못할 경우 생기는 문제
		-	메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
		-	메서드는 문제없이 실행되었지만 잘못된 결과를 반환할 수 있다. 이 결과로 알 수 없는 문제 발생가능

-	public 과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.

-	자바7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.

```java
this.strategy = Objects.requireNonNill(strategy, "전략");
```

-	생성자의 매개변수 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.

-	예외는 있다.

	-	유효성 검사비용이 지나치게 높거나 실용적이지 않을 때
	-	계산과정에서 암묵적으로 검사가 수행될 때

-	메서드는 최대한 범용적으로 설계해야 한다.

	-	메서드가 건네 받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을 수록 좋다.
	-	하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우 검사가 필요하다.

-	책에 있는 핵심 정리

	-	메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야한다.
	-	그 제약들을 문서화하고 메서드 코드 시작부분에서 명시적으로 검사해야 한다.

#### 아이템 50 적시에 방어적 복사본을 만들라

-	자바는 안전한 언어다.

	-	네이티브 메서드를 사용하지 않으니, C, C++ 같이 안전하지 않은 언어에서 흔히 보는 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다.

-	하지만, 다른 클래스로부터의 침범을 아무런 노력없이 다 막을 수 없는 건 아니다.

	-	따라서 클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍 해야한다.

```java
public final class Period {
	private final Date start;
	private final Data end;

	public Period(Date start, Date end){
		if(start.compareTo(end) > 0){
			throw new IllegalArgumentException();
		}

		this.start = start;
		this.end = end;
	}

	public Data start(){
		return start;
	}

	public Date end(){
		return end;
	}
	...
}

// Date가 가변이라는 사실을 이용하여 Period 인스턴스 내부 공격
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p 내부 수정하기
```

-	Date 대신 불변인 Instant 를 사용하면 위의 공격을 방지할 수 있다. (LocalDateTime 이나 ZoneDateTime 사용가능)

	-	Date는 낡은 API이니 새로운 코드를 작성할 때는 더 이상 사용하면 안된다.

-	외부 공격으로부터 Period 인스턴스의 내부를 보호하려면 생성자에게서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.

```java
// 매개변수의 유효성 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성 검사한 예시
public Period(Date start, Date end){

	this.start = new Date(start.getTime());
	this.end = new Date(end.getTime());

	if(this.start.compareTo(this.end) > 0){
		throw new IllegalArgumentException();
	}

}
```

-	멀티스레딩 환경이라면 원본 객체의 유효성 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있으니 위와 같이 작성해야한다. (검사시점/사용 시점 공격)

-	방어적 복사에 Date의 clone 메서드를 사용하지 않는다.

	-	Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수 있다. (이 하위클래스는 start와 end 필드의 참조를 private 정적 리스트에 담아뒀다가 공격자에게 이 리스트를 접근하는 길을 열어 줄 수 있음)

	-	매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안된다.

-	Period 인스턴스는 아직 변경이 가능하다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78); // p 내부 수정하기
```

-	가변필드의 방어적 복사본을 반환하자.

```java
public Data start(){
	return new Date(start.getTime());
}

public Date end(){
	return new Date(end.getTime());
}
```

-	매개변수를 방어적으로 복사하는 목적이 불변객체를 만들기 위해서만은 아니다.

	-	메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야한다.
	-	변경할 수 없어야한다면 방어적본사본을 활용하자.

-	방어적 복사에는 성능 저하가 따르고, 항상 쓸 수 있는 것도 아니다.

	-	호출자가 컴포넌트 내부를 수정하지 않으리라 확실하면 방어적 복사를 생략할 수 있다. (이 상황에도 호출자에서 해당 매개변수나 반환 값을 수정하지 말아야 함을 명확히 문서화하는 게 좋다.)

-	통제권을 넘겨받기로 한 메서드나 생성자를 가진 클래스들은 악의적인 클라이언트의 공격에 취약하다.

	-	방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때, 혹은 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 떄로 한정해야 한다.

-	책에 있는 핵심 정리

	-	클래스가 클라이언트로부터 받은 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
	-	복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하자.

#### 아이템 51 메서드 시그니처를 신중히 설계하라

-	API 설계요령을 설명한다.

-	메서드 이름을 신중히 짓자.

	-	이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는게 최우선 목표이다.
	-	긴 이름은 피하자.
	-	애매하면 자바 라이브러리의 API 가이드를 참조하라.

-	편의 메서드를 너무 많이 만들지 말자.

	-	메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다. (인터페이스도 마찬가지)
	-	아주 자주 쓰일 경우에만 별도의 약칭 메서드를 두자.
	-	확신히 서지 않으면 만들지 말자.

-	매개변수 목록은 짧게 유지히자.

	-	4개 이하가 좋음.
	-	같은 타입의 매개변수 여러 개가 연달아 나오는 경우는 특히 해롭다. (실수가 생길 수 있음)
	-	매개변수 목록을 줄여주는 방법

		-	여러 메서드로 쪼개기
		-	매개변수 여러 개를 묶어주는 도우미 클래스 만들기
		-	두 기법 혼합 (객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용하기)

	-	매개변수의 타입으로는 클래스보다는 인터페이스가 낫다.

		-	매개변수로 적합한 인터페이스가 있다면 그 인터페이스를 직접 사용하자.
		-	ex_ HashMap 말고 Map을 사용하자. (HashMap 뿐만 아니라 TreeMap, ConcurrentHashMap 등을 인수로 건넬 수 있다.)
		-	인터페이스 대신 클래스를 사용하면 클라이언트에게 특정 구현체만 사용하도록 제한하는 꼴이며, 혹시라도 입력 데이터가 다른 형태로 존재한다면 명시한 특정 구현체의 객체로 옮겨 담느라 비싼 복사비용을 지불해야한다.
		-	boolean 보다는 원소 2개짜리 열거 타입이 낫다.

#### 아이템 52 다중정의는 신중히 사용하라

-	재정의한 매서드는 동적으로 선택되고, 다중 정의한 메서드는 정적으로 선택된다.

	-	메서드를 재정의했다면 해당 객체의 런타임 타입이 어떤 메서드를 호출할지의 기준이 된다.
	-	메서드를 재정의한 다음 '하위 클래스의 인스턴스'에서 그 메서드를 호출하면 재정의한 메서드가 실행된다.
	-	다중정의된 메서드 사이에서는 객체의 런타임 타입은 전혀 중요치 않다. 오직 매개변수의 컴파일 타입에 의해 이뤄진다.

-	다중정의가 혼동을 일으키는 상황을 피해야 한다.

	-	API사용자가 매개변수를 넘기면서 어떤 다중정의 메서드가 호출될지를 모르다면 프로그램이 오동작하기 쉽다.
	-	안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.
	-	다중정의하는 대신 메서드 이름을 다르게 지어주는 길도 열려있다.

-	메서드를 다중정의할 때, 사로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다.

-	책에 있는 핵심 정리

	-	프로그래밍 언어가 다중정의를 허용한다고 해서 다중 정의를 꼭 활용하란 뜻은 아니다.
	-	일반적으로 매개변수 수가 같을 때는 다중정의를 피하는 것이 좋다.
	-	상황에 따라, 특히 생성자라면 이 조언을 따르기가 불가능할 수 있다. 그럴 떄는 헷갈릴 만한 매개변수는 형변환하여 정확한 다중정의 메서드가 선택되도록 해야 한다.

		-	이것이 불가능하다면 (기존 클래스를 수정해 새로운 인터페이스를 구현해야 할 때) 같은 객체를 입력받는 다중 정의 메서드들이 모두 동일하게 동작하도록 만들어야 한다.

		-	그렇지 못하면 프로그래머들은 다중정의된 메서드나 생성자를 효과적으로 사용하지 못할 것이고, 의도대로 동작하지 않는 이유를 이해하지 못할 것이다.

#### 아이템 53 가변인수는 신중히 사용하라

-	가변인수 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있다.

-	가변인수 메서드를 호출하면, 가장 먼저 인수의 개수와 길이가 같은 배열을 만들고 인수들을 이 배열에서 저장하여 가변인수 메서드에 건네준다.

```java
static int sum(int... args){
	int sum = 0;
	for(int arg : args){
		sum += arg;
	}
	return sum;
}

// 인수가 1개 이상이어야할 때 가변인수를 제대로 사용하는 방법
static int min(int firstArg, int... remainingArgs){
	int mim = firstArg;
	for(int arg : remainingArgs){
		if (arg < min){
			min = arg;
		}
		return min;
	}
}
```

-	가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화된다. 성능에 민감한 상황인 경우 가변인수가 걸림돌이 될 수 있음

	-	인수가 0개인 것부터 n개 인것까지 다중 정의하여 해소할 수 있다.

-	책에 있는 핵심 정리

	-	인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다.
	-	메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려하자.

#### 아이템 54 null이 아닌, 빈 컬렉션이나 배열을 반환하라

-	컬렉션이나 배열 같은 컨테이너가 비었을 때 null을 반환하는 메서드를 사용할 때면 항시 방어 코드를 넣어줘야한다.

> 클라이언트에서 방어코드를 뺴먹으면 오류가 발생할 수 있다.

-	빈 컨테이너 할당에도 비용이 드니 null을 반환하는 것이 낫다는 주장도 있지만 두 가지면에서 틀리다고 한다.

	-	이 정도 성능 차이는 신경 쓸 수준이 못된다.
	-	빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.

		```java
		public List<Cheese> getCheese(){
		    return new ArrayList<>(cheeseInStock);
		}
		```

	-	가능성은 작지만, 사용 패턴에 따라 빈 컬렉션 할당이 성능을 눈에 띄게 떨어뜨릴 수 있다.

		-	해법은 매번 똑같은 빈 불변 컬렉션을 반환하는 것이다. (Collections.emptyList(), Collections.emptySet(), Collections.emptyMap() )

			```java
			public List<Cheese> getCheese(){
			    return cheeseInStock.isEmpty() ? Collections.emptyList() : new ArrayList<>(cheeseInStock);
			}
			```

		-	배열은 길이가 0인 배열을 반환하라. 혹은 길이가 0짜리 배열을 미리 선언해두고 매번 그 배열을 반환하라

			```java
			public Cheese[] getCheese() {
			    return cheeseInStock.toArray(new Cheese[0]);
			}


			// 길이가 0인 배열 미리 선언
			private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];


			public Cheese[] getCheese(){
			    return cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);
			}
			```

-	단순히 성능을 개선할 목적이라면 toArray에 넘기는 배열을 미리 할당하는 건 추천하지 않는다. 오히려 성능을 떨어뜨린다는 연구 결과도 있다.

	```java
	return cheeseInStock.toArray(new Cheese[cheeseInStock.size()]);
	```

-	책에 있는 핵심 정리

	-	null이 아닌, 빈 배열이나 컬렉션을 반환하라.
	-	null을 반환하는 API는 사용하기 어렵고 오류처리 코드도 늘어난다. 그렇다고 성능이 좋은 것도 아니다.

### 아이템 55 옵셔널 반환은 신중히 하라

-	자바 8 전에는 메서드가 특정 조건에서 값을 반환할 수 없을 떄 취할 수 있는 선택지가 두 가지 있었다. (하지만 두가지 모두 허점이 있다.)

	-	예외를 던지거나
		-	예외는 진짜 예외적인 상황에서만 사용해야 한다. 또한 예외를 생성할 때 스택 추적 전체를 캡처하므로 비용도 만만치 않음
	-	null 반환하거나
		-	별도의 null 처리 코드를 추가해야한다. null 처리를 무시하면 언젠가 NullPointerException 이 발생할 수 있음

-	자바 8 이후로 또 하나의 선택지가 생겼다.

	-	Optional<T>는 null 이 아닌 T 타입 참조를 하나 담거나 아무거나 담지 않을 수 있음
	-	Optional은 원소를 최대 1개 가질 수 있는 불변 컬렉션이다.

-	보통 T를 반환해야 하지만 특정 조건에서는 아무것도 반환하지 않아야 할때 T 대신 Optional<T>를 반환하도록 선언하면 된다.

	-	Optional을 반환하는 메서드는 예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null을 반환하는 메서드보다 오류 가능성이 적다.

> 옵셔널을 반환하는 메서드에서는 절대 null을 반환하지말자. 옵셔널을 도입한 취지를 완전히 무시하는 행위다.

-	옵셔널은 값을 받지못할 때 취할 행동인 기본 값을 설정할 수 있다.

	-	String lastWordInLexion = max(words).orElse("값 없음");

-	옵셔널은 상황에 맞는 예외를 던질 수 있다. (예외 팩터리르 건네고 있는데, 예외가 실제로 발생하지 않는한 예외 생성비용은 들지 않는다.

	-	Toy myToy = max(toy).orElseThrow(TemperTantrumException::new);

-	옵셔널은 항상 값이 채워져있다고 확신한다면 곧바로 값을 꺼내 사용하는 선택지도 있다. (다만 잘못판단한거라면 NoSuchElementException이 발생할 것이다.)

	-	Element lastNobleGas = max(Elements.NOBLE_GASES).get();

-	자바 9에서는 Optional에 stream() 메서드가 추가되었다.

	-	옵셔널에 값이 있다면 그 값을 원소로 담은 스트림으로 변환
	-	값이 없다면 빈 스트림으로 변환

-	컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안된다. 빈 값(컬렉션 등)을 반환하는 게 좋다.

	-	결국 옵셔널 처리 코드가 필요하기 떄문 (Item 54 - null이 아닌, 빈 컬렉션이나 배열을 반환하라 )

-	어떤 경우에 메서드 반환 타입을 T 대신 Optional<T>로 선언해야 할까?

	-	결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 Optional<T>를 반환한다.

	-	하지만, Optional<T> 를 반환하는 데는 대가가 따른다.

		-	Optional로 초기화해야하는 객체이고, 그 안에서 값을 꺼내래면 메서드를 호출해야함.
		-	성능이 중요한 상황에선 주의할 것.
		-	박싱된 기본 타입을 담는 옵셔널은 기본 타입 자체보다 무거울 수 밖에 없음. (int,long,double 전용 옵셔널 클래스 존재함. 이를 사용할 것)

-	옵셔널을 맵의 값으로 사용하면 안된다! (복잡성만 높여서 혼란과 오류 가능성을 키운다.)

	-	맵 안에 키가 없다는 사실을 나타내는 방법이 두 가지가 생김
		-	키 자체가 없는 경우
		-	키는 있지만 그 키가 속이 빈 옵셔널인 경우

> 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적적한 상황은 거의 없다.

-	책에 있는 핵심 정리
	-	값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야하는 메서드라면 옵셔널을 반환해야 할 상활일 수 있다.
	-	하지만 옵셔널 반환에는 성능 저하가 뒤따르니, 성능에 민감한 메서드라면 null을 반환하거나 예외를 던지는 편이 나을 수 있다.
	-	그리고 옵셔널을 반환 값 이외의 용도로 쓰는 경우는 매우 드물다.

### 아이템 56 공개된 API 요소에는 항상 문서화 주석을 작성하라

-	API를 쓸모 있게 하려면 잘 작성된 문서도 곁들어야한다.

	-	자바에서는 자바독(javadoc)이라는 유틸리티가 API 문서 작업을 도와준다.
	-	자바독은 소스코드 파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API문서로 변환해준다.
		-	자바독 유틸리티는 문서화주석을 HTML로 변환함

> API를 올바로 문서화화려면 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야한다.

-	메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.

	-	상속용으로 설계된 클래스의 메서드가 아니라면 무엇을 하는지를(어떻게X) 기술해야한다.
	-	클라이언트가 해당 메서드를 호출하기 위한 전제조건을 모두 나열해야 한다.
	-	메서드가 성공적으로 수행된 후에 만족해야 하는 사후조건도 모두 나열해야 한다.
	-	일반적으로 전제조건은 @throws 태그로 비검사 예외를 선언하여 암시적으로 기술하다.
	-	@param 태그를 이용해 그 조건에 영향받는 매개변수에 기술할 수 도 있다.
	-	부작용도 문서화해야 한다.

-	@return : 변환타입이 void가 아닐 때. 해당 매개변수가 뜻하는 값이나 반환 값을 설명하는 명사구 사용.

-	@implSepc : 자기사용 패턴. 그 메서드를 올바로 재정의하는 방법. 해당 메서드와 하위 클래스 사이의 계약을 설명하여, 하위 클래스들이 그 메서드를 상속하거나 super 키워드를 이용해 호출할 때 그 메서드가 어떻게 동작하는 지 명확히 인지하고 사용하도록 해줘야함.

-	제네릭 타입이나 제너렉 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야한다.

-	열거타입을 문서화할 때는 상수들에도 주석을 달아야한다.

-	애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야한다.

-	API 문서화에서 자주누락되는 설명이 두 가지 있다. (스레드 안전성, 직렬화 가능성)

	-	클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API 설명에 포함해야 한다.
	-	직렬화할 수 있는 클래스라면 직렬화 형태도 API 설명에 기술해야 한다.

-	문서화 주석을 달았더라도, 충분하지 않는 경우 관련 클래스나 패키지의 문서화 주석에서 그 문서의 링크를 제공해주면 좋다.

-	자세한 지침은 javadoc-guide 참고

-	책에 있는 핵심 정리

	-	문서화 주석은 AP를 문서화하는 가장 훌륭하고 효과적인 방법이다.
	-	공개 API라면 빠짐없이 설명을 달아야 한다.
	-	표준 규약을 일관되게 지키자.
	-	문서화 주석에 임의의 HTML 태그를 사용할 수 있다. (HTML 메타문자는 특벼랗게 취급해야 한다.)
