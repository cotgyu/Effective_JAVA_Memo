이펙티브 자바
-------------

---

### 10장 예외

-	예외를 제대로 활용한다면 프로그램의 가독성, 신뢰성, 유지보수성이 높아지지만, 잘못사용하면 반대의 효과만 나타난다.

#### 아이템 69 예외는 진짜 예외 상황에만 사용하라

-	예외를 사용한 반복문의 해악은 코드를 헷갈리게 하고 성능을 떨어뜨리는데서 끝나지 않는다.
	-	반복문 안에 버그가 숨어있다면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게 할 것이다.

> 예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.

-	잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야한다.

-	상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침

	-	외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문
	-	성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
	-	다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. 상태 검사 메서드 호출을 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다.

#### 아이템 70 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

-	자바는 문제 상황을 알리는 타입(throwable)으로 검사 예외, 런타임 예외, 에러 이렇게 세가지를 제공한다.

-	호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.

	-	검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 바깥으로 전파도록 강제하게 된다.
	-	따라서 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것이다.

-	비검사 예외 throwable은 두 가지로 런타임 예외와 에러다.

	-	프로그램에서 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.

> 프로그램 오류를 나타낼 때는 런타임 예외를 사용하자.

-	런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.

	-	전제조건 위배란 단순히 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못헀다는 뜻

-	에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.

	-	자바 언어 명세가 요구하는 것은 아니지만 업계에 퍼진 규약이니, Error 클래스를 상속해 하위 클래스를 만드는 일은 자제...
	-	다시 말해, 구현하는 비검사 throwable 은 모두 RuntimeException의 하위 클래스여야 한다.

	-	Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야한다.

-	Exception, RuntimeException, Error 를 상속하지 않는 throwable를 만들 수도 있지만, 이로울게 없으니 사용하지 말자.

-	검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다.

	-	따라서 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다.

-	책에 있는 핵심 정리

	-	복구할 수 있는 상황이라면 검사 예외를, 프로그래밍 오류라면 빅머사 예외를 던지자.
	-	확실하지 않다면 비검사 예외를 던지자.
	-	검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.

#### 아이템 71 필요 없는 검사 예외 사용은 피하라

-	결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안정성을 높이게끔 해준다.

	-	하지만 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다.

-	API를 제대로 사용해도 발생할 수 있는 예외이거나 프로그래머가 의미 있는 조치를 취할 수 있는 경우

	-	이 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 게 좋다.

-	검사 예외가 단 하나뿐이라면 오직 그 예외 때문에 API 사용자는 try 블록을 추가해야 하고 스트림에서 직접 사용하지 못하게 된다.

	-	이런 상황이라면 검사 예외를 안 던지는 방법이 없는지 고민해볼 가치가 있다.
	-	검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것. (검사예외를 던지는 대신 빈 옵셔널을 반환하면 됨)
		-	단점이라면 예외가 발생한 이유를 알려주는 부가정보를 담을 수 없음
		-	반면, 예외를 사용하면 구체적인 예외타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있음

-	책에 있는 핵심 정리

	-	꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다.
	-	API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
	-	복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.
	-	**옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할수 없을 때만 검사 예외를 던지자.**

#### 아이템 72 표준 예외를 사용하라

-	숙련된 프로그래머는 많은 코드를 재사용한다.

	-	예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에 쓰기 충분한 수의 예외를 제공한다.

-	표준 예외를 재사용하면 얻는게 많다.

	-	익히고 사용하기 쉬워짐
	-	예외 클래스 수가 적을 수록 메모리 사용량이 줄고 클래스를 적재한느 시간도 적게 걸림

-	많이 재사용되는 예외

	-	IllegalArgumentException
	-	IllegalStateException
	-	ConcurrentModificationException
	-	UnsupportedOperationException

-	Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.

	-	이 예외들은 다른 예외들의 상위 클래스이므로, 안정적으로 테스트할 수 없다. (여러 성격의 예외들을 포괄하는 클래스)

#### 아이템 73 추상화 수준에 맞는 예외를 던져라

-	메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 수행하려는 일과 관련 없어보이는 에외가 튀어나올 수 있다.

	-	이는 내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다.
	-	이 문제를 피하려면 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야한다. (예외 번역 exception translation)

```java
// 예외 번역
public E get(int index){
	ListIterator<E> i = listIterator(index);
	try{
		return i.next();
	} catch (NoSuchElementException e){
		throw new IndexOutOfBoundsException("인데스: " +i index);
	}
}


// 예외 연쇄 (저수준 예외가 디버깅에 도움이 된다면 사용)
try{
	...
}catch (LowerLevelException cause){
	throw new HigherLevelException(cause);
}

// 예외 연쇄용 생성자
class HigherLevelException extends Exception {
	HigherLevelException(Throwable cause) {
		super(cause);
	}
}
```

-	대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.

	-	그렇지 않은 예외라도 Throwable의 initCause 메서드를 통해 원인을 직접 못박을 수 있다.

-	무턱대고 예외를 전파하는 것보다 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다.

	-	가능하면 저수준 메서드가 반드시 성공하도록하여 아래계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.

	-	때론 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 이 목적을 달성할 수 있다.

	-	아래 계층에서 예외를 피할 수 없다면 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에까지 전파하지 않는 방법이 있다.

		-	이 경우 발생한 예외는 java.util.logging 같은 적절한 로깅 기능을 활용하여 기록해두면 좋음

-	책에 있는 핵심 정리

	-	아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라.
	-	이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.

#### 아이템 74 메서드가 던지는 모든 예외를 문서화하라

-	메서드가 던지는 예외는 그 메서드를 올바로 사용하는데 아주 중요한 정보다.

> 검사 예외는 항상 따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.

-	공통 상위 클래스 하나로 뭉뚱그려 선언하는 일은 삼가자.

	-	예로 메서드가 Exception이나 Throwable을 던진다고 선언해서는 안된다.
	-	메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할뿐더러, 같은 맥락에서 발생할 여지가 있는 다른 예외들까지 삼켜버릴 수 있어 API 사용성을 크게 떨어뜨린다.
	-	이 규칙의 유일한 예외는 main 메서드임 (main은 오직 JVM만이 호출하므로 Exception을 던지도록 선언해도 괜찮다)

-	비검사 예외도 문서화해두면 좋다.

	-	비검사 예외는 프로그래밍 오류를 뜻하는데, 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.

	-	public 메서드라면 필요한 전제조건을 문서화해야하며, 그 수단으로 가장 좋은 것이 바로 비검사 예외들을 문서화하는 것이다.

-	메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.

	-	검사냐 비검사냐에 따라 API 사용자가 해야 할 일이 달라지므로, 이 둘을 확실히 구분해주는 게 좋다.

	-	자바독 유틸리티는 메서드 선언의 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으로 구분해준다.

		-	프로그래머는 어느 것이 비검사 예외인지를 바로 알 수 있다.

-	한 클래스에 정의된 많은 메서드가 같은 이유로 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 있다.

	-	ex_ NullPointerException

#### 아이템 75 예외의 상세 메시지에 실패 관련 정보를 담으라

-	예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 스택 추적 정보를 자동으로 출력한다.

	-	스택 추적은 예외 객체의 toString 메서드를 호출해 얻는 문자열로, 보통 예외의 클래스 이름 뒤에 상세 메시지가 붙은 형태이다.
	-	이 정보가 실패 원인을 분석해야할 유일한 정보일 수 있다.
	-	실패의 원인에 관한 정보를 가능한 한 많이 담아 반환하는 일은 아주 중요하다.

-	실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.

-	예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안 된다.

	-	최종 사용자에게는 안내 메시지, 예외 메시지는 가독성보다는 담긴 내용이 훨씬 중요함

-	필요한 정보를 예외 생성자에서 모두 받아서 상세 메시지까지 미리 생성해놓는 방법도 괜찮다.

-	예외는 실패와 관련도니 정보를 얻을 수 있는 접근자 메서드를 적절히 제공하는 것이 좋다. (아이템 70)

#### 아이템 76 가능한 한 실패 원자적으로 만들라

> 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.

-	이러한 특성을 실패 원자적이라 한다.

-	메서드를 실패 원자적으로 만드는 방법

	-	불변 객체로 설계

		-	메서드가 실패하면 새로운 객체가 만들어지지는 않을 수 있으나 기존 객체가 불안정한 상태에 빠지는 일은 없다.

	-	작업 수행에 앞서 매개변수의 유효성을 검사하기

		-	객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성 대부분을 걸러낼 수 있는 방법

	-	객체의 임시 본사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 방법

		-	데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식임

	-	작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법

		-	주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰임

-	실패 원자성은 일반적으로 권장되는 덕목이지만 항상 달성할 수 있는 것은 아님

-	실패 원자성을 만들 수 있더라도 항상 해야하는 것도 아님

	-	실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산도 있을 수 있음

-	메서드 명세에 기술한 예외라면 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다는 것이 기본 규칙임

	-	이 규직을 지키지 못한다면 실패 시의 객체 상태를 API 설명에 명시해야 함!

#### 아이템 77 예외를 무시하지 말라

-	API 설계자가 메서드 선언에 예외를 명시하는 까닭은, 그 메서드를 사용할 때 적절한 조치를 취해달라고 말하는 것이다.

	-	설계자의 목소리를 흘려버리지 말자.

-	catch 블록을 비워두면 예외가 존재할 이유가 없어진다.

-	물론 예외를 무시해야할 떄도 있다

	-	ex_ FileInputStream을 닫을 때

-	예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔놓도록 하자.

```java
Future<Integer> f = exec.submit(planarMap::chromaticNumber);

int numColors = 4;

try{
	numColors = f.get(1L, TimeUnit.SECONDS);
} catch(TimeoutException | ExecutionException ignored) {

}
```

-	예외를 적절히 처리하면 오류를 완전히 피할 수도 있다.
	-	무시하지 않고 바깥으로 전파되게만 놔둬도 최소환 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게는 할 수 있다.
