이펙티브 자바
-------------

---

### 10장 예외

-	예외를 제대로 활용한다면 프로그램의 가독성, 신뢰성, 유지보수성이 높아지지만, 잘못사용하면 반대의 효과만 나타난다.

#### 아이템 69 예외는 진짜 예외 상황에만 사용하라

-	예외를 사용한 반복문의 해악은 코드를 헷갈리게 하고 성능을 떨어뜨리는데서 끝나지 않는다.
	-	반복문 안에 버그가 숨어있다면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게 할 것이다.

> 예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.

-	잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야한다.

-	상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침

	-	외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문
	-	성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
	-	다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. 상태 검사 메서드 호출을 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다.

#### 아이템 70 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

-	자바는 문제 상황을 알리는 타입(throwable)으로 검사 예외, 런타임 예외, 에러 이렇게 세가지를 제공한다.

-	호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.

	-	검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 바깥으로 전파도록 강제하게 된다.
	-	따라서 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것이다.

-	비검사 예외 throwable은 두 가지로 런타임 예외와 에러다.

	-	프로그램에서 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻이다.

> 프로그램 오류를 나타낼 때는 런타임 예외를 사용하자.

-	런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.

	-	전제조건 위배란 단순히 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못헀다는 뜻

-	에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.

	-	자바 언어 명세가 요구하는 것은 아니지만 업계에 퍼진 규약이니, Error 클래스를 상속해 하위 클래스를 만드는 일은 자제...
	-	다시 말해, 구현하는 비검사 throwable 은 모두 RuntimeException의 하위 클래스여야 한다.

	-	Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야한다.

-	Exception, RuntimeException, Error 를 상속하지 않는 throwable를 만들 수도 있지만, 이로울게 없으니 사용하지 말자.

-	검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다.

	-	따라서 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다.

-	책에 있는 핵심 정리

	-	복구할 수 있는 상황이라면 검사 예외를, 프로그래밍 오류라면 빅머사 예외를 던지자.
	-	확실하지 않다면 비검사 예외를 던지자.
	-	검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.

#### 아이템 71 필요 없는 검사 예외 사용은 피하라

-	결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안정성을 높이게끔 해준다.

	-	하지만 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 된다.

-	API를 제대로 사용해도 발생할 수 있는 예외이거나 프로그래머가 의미 있는 조치를 취할 수 있는 경우

	-	이 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 게 좋다.

-	검사 예외가 단 하나뿐이라면 오직 그 예외 때문에 API 사용자는 try 블록을 추가해야 하고 스트림에서 직접 사용하지 못하게 된다.

	-	이런 상황이라면 검사 예외를 안 던지는 방법이 없는지 고민해볼 가치가 있다.
	-	검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것. (검사예외를 던지는 대신 빈 옵셔널을 반환하면 됨)
		-	단점이라면 예외가 발생한 이유를 알려주는 부가정보를 담을 수 없음
		-	반면, 예외를 사용하면 구체적인 예외타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있음

-	책에 있는 핵심 정리

	-	꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다.
	-	API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
	-	복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.
	-	**옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할수 없을 때만 검사 예외를 던지자.**

#### 아이템 72 표준 예외를 사용하라

-	숙련된 프로그래머는 많은 코드를 재사용한다.

	-	예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에 쓰기 충분한 수의 예외를 제공한다.

-	표준 예외를 재사용하면 얻는게 많다.

	-	익히고 사용하기 쉬워짐
	-	예외 클래스 수가 적을 수록 메모리 사용량이 줄고 클래스를 적재한느 시간도 적게 걸림

-	많이 재사용되는 예외

	-	IllegalArgumentException
	-	IllegalStateException
	-	ConcurrentModificationException
	-	UnsupportedOperationException

-	Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.

	-	이 예외들은 다른 예외들의 상위 클래스이므로, 안정적으로 테스트할 수 없다. (여러 성격의 예외들을 포괄하는 클래스)

#### 아이템 73 추상화 수준에 맞는 예외를 던져라

-	메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 수행하려는 일과 관련 없어보이는 에외가 튀어나올 수 있다.

	-	이는 내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다.
	-	이 문제를 피하려면 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야한다. (예외 번역 exception translation)

```java
// 예외 번역
public E get(int index){
	ListIterator<E> i = listIterator(index);
	try{
		return i.next();
	} catch (NoSuchElementException e){
		throw new IndexOutOfBoundsException("인데스: " +i index);
	}
}


// 예외 연쇄 (저수준 예외가 디버깅에 도움이 된다면 사용)
try{
	...
}catch (LowerLevelException cause){
	throw new HigherLevelException(cause);
}

// 예외 연쇄용 생성자
class HigherLevelException extends Exception {
	HigherLevelException(Throwable cause) {
		super(cause);
	}
}
```

-	대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.

	-	그렇지 않은 예외라도 Throwable의 initCause 메서드를 통해 원인을 직접 못박을 수 있다.

-	무턱대고 예외를 전파하는 것보다 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다.

	-	가능하면 저수준 메서드가 반드시 성공하도록하여 아래계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.

	-	때론 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 이 목적을 달성할 수 있다.

	-	아래 계층에서 예외를 피할 수 없다면 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에까지 전파하지 않는 방법이 있다.

		-	이 경우 발생한 예외는 java.util.logging 같은 적절한 로깅 기능을 활용하여 기록해두면 좋음

-	책에 있는 핵심 정리

	-	아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라.
	-	이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.
