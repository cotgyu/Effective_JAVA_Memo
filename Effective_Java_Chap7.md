이펙티브 자바
-------------

---

### 7장 람다와 스트림

-	자바 8에서 추가된 함수형 인터페이스, 람다, 메서드 참조 개념으로 함수객체를 더 쉽게 만들 수 있게 되었다. 이 기능들을 효과적으로 사용하는 방법을 알아보자

#### 아아템 42 익명 클래스보다 람다를 사용하라

```java
// 익명클래스의 인스턴스를 함수겍체로 사용 - 낡은 기법
Collections.sort(words, new Comparator<String>(){
	public int compare(String s1, String s2){
		return Integer.compare(s1.length(), s2.length());
	}
});
```

-	위의 익명클래스 방식은 코드가 너무 길기 때문에 함수형 프로그래밍에 적합하지 않다.

```java
// 익명클래스를 대체하여 람다식을 함수 객체로 사용
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

-	매개변수(s1,s2), 반환 값의 타입이 코드에서 언급이 없다. (컴파일러가 타입을 추론해준다.)

	-	상황에 따라 컴파일러가 타입을 추론하지 못할 때는 프로그래머가 직접 명시해줘야한다.

> 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다는 모든 매개변수 타입은 생략하자. (컴파일러 오류가 날때만 명시해주자)

```java
// 람다 자리에 비교자 생성 메서드 사용 예제
Collection.sort(words, comparingInt(String::length));

// 자바 8의 sort 메서드 이용
words.wort(comparingInt(String::length));
```

-	메서드나 클래스와 달리, 람다는 이름이 없고 문서화도 못한다.

	-	따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수 가 많아지면 람다를 쓰지 말아야 한다. (1~3줄)

	-	람다가 길거나 읽기 어렵다면 더 간단히 줄여보거나, 람다를 쓰지 않는 쪽으로 리팩터링을 권장한다.

-	람다는 함수형 인터페이스에서만 쓰인다.

	-	추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명클래스를 써야한다.
	-	추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명클래스를 쓸 수 있다.
	-	함수 객체가 자신을 참조해야한다면 익명클래스를 써야한다. (람다에서의 this는 바깥 인스턴스를 가리킨다.)

-	람다도 익명클래스처럼 직렬화 형태가 구현별로(가령 가상머신별로) 다를 수 있다.

	-	람다를 직렬화하는 일은 극히 삼가야 한다.
	-	직렬화해야 하는 함수 객체가 있다면(ex_ Comparator) private 정적 중첩 클래스의 인스턴스를 사용하자.

-	책에 있는 핵심 정리

	-	익명클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하라.
	-	람다는 작은 함수 객체를 아주 쉽게 표현할 수 있다.

#### 아이템 43 람다보다는 메서드 참조를 사용하라

-	자바에는 함수 객체를 람다보다 더 간결하게 만드는 방법이 있다. (메서드 참조)

	-	메서드 참조를 사용하는 편이 보통 더 짧고 간결하다.

-	메서드 참조의 유형은 다섯가지이다.

	-	정적 메서드를 가리키는 메서드 참조
	-	한정적 인스턴스 메서드를 참조
	-	비한정적 인스턴스 메서드 참조
	-	클래스 생성자를 가리키는 메서드 참조
	-	배열 생성자를 가리키는 메서드 참조

	```java
	map.merge(key, 1, (count, incr) -> count + incr);


	// 메서드 참조 사용
	map.merge(key, 1, Integer::sum);


	// 유형별 예시
	// 정적
	str -> Integer.parseInt(str)
	Integer::parseInt


	// 한정적 인스턴스
	Instant then = Instant.now();
	t -> then.isAfter(t)


	// 비한정적 인스턴스
	str -> str.toLowerCase()
	String::toLowerCase


	// 클래스 생성자
	() -> new TreeMap<K,V>()


	// 배열 생성자
	len -> new int[len]
	int[]::new
	```

-	책에 있는 핵심 정리

	-	메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.

#### 아이템 44 표준 함수형 인터페이스를 사용하라

-	java.util.function 패키지를 보면 다양한 용도의 표준 함수형 인터페이스가 있다.

> 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.

-	java.util.finction 패키지에는 43개의 인터페이스가 있지만, 기본 인터페이스 6가지만 기억하면 나머지를 충분히 유추해볼 수 있다.

	-	UnaryOperator<T> (ex_ String::toLowerCase )
	-	BinaryOperator<T> (ex_ BigInteger::add )
	-	Predicate<T> (ex_ Collection::isEmpty )
	-	Function<T> (ex_ Arrays::asList )
	-	Supplier<T> (ex_ Instant::now )
	-	Consumer<T> (ex_ System.out::println )

-	표준 함수형 인터페이스 대부분은 기본 타입만 지원한다.

	-	기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자. (성능이 느려질 수 있다.)

-	표준 인터페이스 중 필요한 용도에 맞는게 없다면 직접 작성해야 한다.

-	직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하라.

	-	해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
	-	해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
	-	유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막는다.

-	서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안된다.
