이펙티브 자바
-------------

---

### 7장 람다와 스트림

-	자바 8에서 추가된 함수형 인터페이스, 람다, 메서드 참조 개념으로 함수객체를 더 쉽게 만들 수 있게 되었다. 이 기능들을 효과적으로 사용하는 방법을 알아보자

#### 아아템 42 익명 클래스보다 람다를 사용하라

```java
// 익명클래스의 인스턴스를 함수겍체로 사용 - 낡은 기법
Collections.sort(words, new Comparator<String>(){
	public int compare(String s1, String s2){
		return Integer.compare(s1.length(), s2.length());
	}
});
```

-	위의 익명클래스 방식은 코드가 너무 길기 때문에 함수형 프로그래밍에 적합하지 않다.

```java
// 익명클래스를 대체하여 람다식을 함수 객체로 사용
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

-	매개변수(s1,s2), 반환 값의 타입이 코드에서 언급이 없다. (컴파일러가 타입을 추론해준다.)

	-	상황에 따라 컴파일러가 타입을 추론하지 못할 때는 프로그래머가 직접 명시해줘야한다.

> 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다는 모든 매개변수 타입은 생략하자. (컴파일러 오류가 날때만 명시해주자)

```java
// 람다 자리에 비교자 생성 메서드 사용 예제
Collection.sort(words, comparingInt(String::length));

// 자바 8의 sort 메서드 이용
words.wort(comparingInt(String::length));
```

-	메서드나 클래스와 달리, 람다는 이름이 없고 문서화도 못한다.

	-	따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수 가 많아지면 람다를 쓰지 말아야 한다. (1~3줄)

	-	람다가 길거나 읽기 어렵다면 더 간단히 줄여보거나, 람다를 쓰지 않는 쪽으로 리팩터링을 권장한다.

-	람다는 함수형 인터페이스에서만 쓰인다.

	-	추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명클래스를 써야한다.
	-	추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명클래스를 쓸 수 있다.
	-	함수 객체가 자신을 참조해야한다면 익명클래스를 써야한다. (람다에서의 this는 바깥 인스턴스를 가리킨다.)

-	람다도 익명클래스처럼 직렬화 형태가 구현별로(가령 가상머신별로) 다를 수 있다.

	-	람다를 직렬화하는 일은 극히 삼가야 한다.
	-	직렬화해야 하는 함수 객체가 있다면(ex_ Comparator) private 정적 중첩 클래스의 인스턴스를 사용하자.

-	책에 있는 핵심 정리

	-	익명클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하라.
	-	람다는 작은 함수 객체를 아주 쉽게 표현할 수 있다.

#### 아이템 43 람다보다는 메서드 참조를 사용하라

-	자바에는 함수 객체를 람다보다 더 간결하게 만드는 방법이 있다. (메서드 참조)

	-	메서드 참조를 사용하는 편이 보통 더 짧고 간결하다.

-	메서드 참조의 유형은 다섯가지이다.

	-	정적 메서드를 가리키는 메서드 참조
	-	한정적 인스턴스 메서드를 참조
	-	비한정적 인스턴스 메서드 참조
	-	클래스 생성자를 가리키는 메서드 참조
	-	배열 생성자를 가리키는 메서드 참조

	```java
	map.merge(key, 1, (count, incr) -> count + incr);


	// 메서드 참조 사용
	map.merge(key, 1, Integer::sum);


	// 유형별 예시
	// 정적
	str -> Integer.parseInt(str)
	Integer::parseInt


	// 한정적 인스턴스
	Instant then = Instant.now();
	t -> then.isAfter(t)


	// 비한정적 인스턴스
	str -> str.toLowerCase()
	String::toLowerCase


	// 클래스 생성자
	() -> new TreeMap<K,V>()


	// 배열 생성자
	len -> new int[len]
	int[]::new
	```

-	책에 있는 핵심 정리

	-	메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.

#### 아이템 44 표준 함수형 인터페이스를 사용하라

-	java.util.function 패키지를 보면 다양한 용도의 표준 함수형 인터페이스가 있다.

> 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.

-	java.util.finction 패키지에는 43개의 인터페이스가 있지만, 기본 인터페이스 6가지만 기억하면 나머지를 충분히 유추해볼 수 있다.

	-	UnaryOperator<T> (ex_ String::toLowerCase )
	-	BinaryOperator<T> (ex_ BigInteger::add )
	-	Predicate<T> (ex_ Collection::isEmpty )
	-	Function<T> (ex_ Arrays::asList )
	-	Supplier<T> (ex_ Instant::now )
	-	Consumer<T> (ex_ System.out::println )

-	표준 함수형 인터페이스 대부분은 기본 타입만 지원한다.

	-	기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자. (성능이 느려질 수 있다.)

-	표준 인터페이스 중 필요한 용도에 맞는게 없다면 직접 작성해야 한다.

-	직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하라.

	-	해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
	-	해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
	-	유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막는다.

-	서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안된다.

#### 아이템 45 스트림은 주의해서 사용하라

-	스트림 API는 다량의 데이터 처리 작업을 돕고자 자바 8에 추가되었다.

-	스트림 파이프 라인은 지연 평가 된다.

	-	평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
	-	지연 평가가 무한스트림을 다룰 수 있게 해준다.

-	스트림 API는 메서드 연쇄를 지원하는 플루언트(fluent API) API다.

	-	기본적으로 스트림 파이프라인은 순차적으로 수행되나, parallel 메서드를 통해 병렬 실행 가능하다. (하지만, 효과를 볼 수 있는 상황이 많지 않다.)

-	스트림을 제대로 사용하면 프로그램이 짧고 깔끔해지지만, 잘못 사용하면 읽기 어렵고 유지보수도 힘들어진다.

-	스트림에 안성 맞춤인 작업

	-	원소들의 시퀀스를 일관된게 변환한다.
	-	원소들의 시퀀스를 필터링한다.
	-	원소들의 시퀀스를 하나의 연산을 사용해 결합한다. (더하기, 연결, 최소값구하기 등)
	-	원소들의 시퀀스를 컬렉션에 모은다.
	-	원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

-	스트림으로 처리하기 어려운 일

	-	데이터가 파이프라인의 여러 단계를 통과할 때 이데이터의 각 단계에서의 값들에 동시에 접근하기
	-	스트림 파이프라인은 일단 한 값을 다른 값에 매핑하고 나면 원래의 값은 잃는 구조이기 때문이다.

-	책에 있는 핵심 정리

	-	스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라.

#### 아이템 46 스트림에서는 부작용 없는 함수를 사용하라

-	스트림 패러다임의 핵심은 일련의 변환으로 재구성하는 부분이다.

	-	각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수함수여야 한다.

		-	순수 함수: 오직 입력만이 결과에 영향을 주는 함수, 함수 스스로도 다른 상태를 변경하지 않는다.

	-	스트림 연산에 건네받은 함수 객체는 모두 부작용(Side Effect)이 없어야 한다.

-	forEach 연산은 종단 연산 중 가장 기능이 작고, 가장 덜 스트림답다. forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산할 때는 사용하지 말자. (대놓고 반복적이라 병렬화할 수도 없다)

-	toMap, groupingBy, joining 에 대해 설명하고 있다.

-	책에 있는 핵심 정리

	-	스트릠 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다. (스트림 뿐만 아니라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야한다)
	-	forEach는 스트림이 수행한 계산 결과를 보고할 때만 이용해야 한다.
	-	스트림을 올바로 사용하려면 수집기를 잘 알아둬야 한다. (toList, toSet, toMap, groupingBy, joining)

#### 아이템 47 반환 타입으로는 스트림보다 컬렉션이 낫다

-	자바 7까지는 일련의 원소를 반환하는 메서드의 반환 타입으로 Collection, Set, List 같은 컬렉션 인터페이스, 혹은 Iterable 이나 배열을 썼다.

-	API를 스트림만 반환하도록 짜놓으면 반환된 스트림을 for-each로 반복하길 원하는 사용자는 당연히 불만을 토로할 것이다.

-	원소 시퀀스를 반환하는 공개 API의 반환타입에는 Collection이나 그 하위 타입을 쓰는 것이 최선이다.

	-	Collection 인터페이스는 Iterable의 하위타입이고 stream 메서드도 제공하니 반복과 스트림을 동시에 지원한다.

	-	Arrays 역시 Arrays.asList와 Stream.or 메서드로 반복과 스트림을 지원할 수 있다.

	-	반환하는 시퀀스 스키가 메모리에 올려도 안전할 만큼 작다면 ArrayList나 HashSet 같은 표준 컬렉션 구현체를 반환하는 게 최선일 수 있다.

		-	하지만 단지 컬렉션을 반환한다는 이유로 덩치 큰 시퀀스를 메모리에 올려서는 안된다.

-	책에 있는 핵심 정리

	-	원소 시퀀스를 반환하는 메서드를 작성할 때는 스트림 혹은 반복으로 처리하기를 원하는 사용자가 있음을 떠올리고, 양쪽 다 만족시키려고 노력하자.
	-	컬렉션을 반환할 수 있다면 그렇게 해라.
	-	컬렉션을 반환하는 게 불가능하다면 스트림과 Iterable 중 더 자연스러운 것을 반환하라.

#### 아이템 48 스트림 병렬화는 주의해서 적용하라

-	자바7에서는 고성능 병렬분해 프레임워크인 포크-조인 프레임워크, 자바 8에서는 parallel 메서드를 통해 파이프라인을 병렬로 실행할 수 있는 스트림을 지원했다.

-	자바로 동시성 프로그램을 작성하기가 점점 쉬워지고는 있지만, 이를 올바르고 빠르게 작성하는 일은 여전히 어려운 일이다.

	-	동시성 프로그램은 안전성, 응답 가능 상태를 유지하기 위해 애써야 한다.

-	환경이 아무리 좋더라도 데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.

-	대체로 스트림 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.

	-	이 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있다.
	-	원소들을 순차적으로 실행할 때의 참조 지역성이 뛰어나다. (특히 기본타입의 배열이 뛰어남)

-	스트림 파이프라인의 종단 연산의 동작 방식도 병렬 수행 효율에 영향을 준다.

	-	종단 연산에서 수행하는 작업량이 전체 작업에서 상당 비중을 차지하면서 순차적인 연산이라면 병렬 수행효과는 제한된다.
	-	종단연산 중 병렬화에 가장 적합한 것은 축소(reduction)이다.
		-	reduce, min, max, count, sum
	-	조건에 맞으면 바로 반환되는 메서드도 적합함
		-	anyMatch, allMatch, nonMatch
	-	하지만 가변 축소를 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다. (칼렉션을 합치는 부담이 크다.)

-	직접 구현한 Stream, Iterable, Collection의 병렬화의 이점을 누리게 하고 싶다면 spliterator 메서드를 반드시 재정의하고 결과 스트림의 병렬화 성능을 강도 높게 테스트하라.

-	스트림을 잘못 병렬화하면 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.

> 스트림 병렬화는 오직 성능 최적화 수단임을 기억해라.

-	이상적으로는 운영 시스템과 흡사한 환경에서 테스트하는 것이 좋다.

	-	병렬 스트림 파이프라인도 공통의 포크-조인 풀에서 수행되므로(같은 스레드 풀 사용) 잘못된 파이프라인 하나가 시스템의 다른 부분의 성능에 까지 악영향을 줄 수 있다.

-	조건이 잘 갖춰지면 parellel 메서드 호출하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있다.

-	책에 있는 핵심 정리

	-	계산도 올바로 수행하고 성능도 빨라질 거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말라.
		-	잘못 병렬화하면 프로그램을 오동작하게 하거나 성능을 급격하게 떨어뜨린다.
	-	병렬화하는 편이 낫다고 믿더라도, 운영환경과 유사한 조건에서 수행해보며 성능 지표를 유심히 관찰하라. 그 후에 반영하라.
