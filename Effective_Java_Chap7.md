이펙티브 자바
-------------

---

### 7장 람다와 스트림

-	자바 8에서 추가된 함수형 인터페이스, 람다, 메서드 참조 개념으로 함수객체를 더 쉽게 만들 수 있게 되었다. 이 기능들을 효과적으로 사용하는 방법을 알아보자

#### 아아템 42 익명 클래스보다 람다를 사용하라

```java
// 익명클래스의 인스턴스를 함수겍체로 사용 - 낡은 기법
Collections.sort(words, new Comparator<String>(){
	public int compare(String s1, String s2){
		return Integer.compare(s1.length(), s2.length());
	}
});
```

-	위의 익명클래스 방식은 코드가 너무 길기 때문에 함수형 프로그래밍에 적합하지 않다.

```java
// 익명클래스를 대체하여 람다식을 함수 객체로 사용
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

-	매개변수(s1,s2), 반환 값의 타입이 코드에서 언급이 없다. (컴파일러가 타입을 추론해준다.)

	-	상황에 따라 컴파일러가 타입을 추론하지 못할 때는 프로그래머가 직접 명시해줘야한다.

> 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다는 모든 매개변수 타입은 생략하자. (컴파일러 오류가 날때만 명시해주자)

```java
// 람다 자리에 비교자 생성 메서드 사용 예제
Collection.sort(words, comparingInt(String::length));

// 자바 8의 sort 메서드 이용
words.wort(comparingInt(String::length));
```

-	메서드나 클래스와 달리, 람다는 이름이 없고 문서화도 못한다.

	-	따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수 가 많아지면 람다를 쓰지 말아야 한다. (1~3줄)

	-	람다가 길거나 읽기 어렵다면 더 간단히 줄여보거나, 람다를 쓰지 않는 쪽으로 리팩터링을 권장한다.

-	람다는 함수형 인터페이스에서만 쓰인다.

	-	추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명클래스를 써야한다.
	-	추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명클래스를 쓸 수 있다.
	-	함수 객체가 자신을 참조해야한다면 익명클래스를 써야한다. (람다에서의 this는 바깥 인스턴스를 가리킨다.)

-	람다도 익명클래스처럼 직렬화 형태가 구현별로(가령 가상머신별로) 다를 수 있다.

	-	람다를 직렬화하는 일은 극히 삼가야 한다.
	-	직렬화해야 하는 함수 객체가 있다면(ex_ Comparator) private 정적 중첩 클래스의 인스턴스를 사용하자.

-	책에 있는 핵심 정리

	-	익명클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하라.
	-	람다는 작은 함수 객체를 아주 쉽게 표현할 수 있다.
