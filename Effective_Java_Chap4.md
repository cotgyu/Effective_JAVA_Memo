이펙티브 자바
-------------

---

### 4장 클래스와 인터페이스

#### 아이템 15 : 클래스와 멤버의 접근 권한을 최소화하라

-	잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.

	-	오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작방식에는 전혀 개의치 않는다.

-	정보 은닉의 장점

	-	시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있다.
	-	시스템 관리 비용을 낮춘다. 각 컴포넌트를 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.
	-	정보 은닉 자체가 성능을 높여주진 않지만, 성능 최적화에 도움을 준다. 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문
	-	소프트웨어 재사용을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작하는 컴포넌트라면 낯선환경에서도 유용하게 쓰일 가능성이 크다.
	-	시스템 전체가 완성되지 않은 상태에서도 개발 컴포넌트의 동작을 검증할 수 있다.

-	자바의 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해진다.

	-	이 접근제한자를 제대로 활용하는 것이 정보 은닉의 핵심

	> 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.

	-	private : 멤버를 선언한 톱 레벨 클래스에서만 접근할 수 있다.
	-	package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. (접근제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준. 단, 인터페이스의 멤버는 기본적으로 public)
	-	protected : package-private의 접근범위를 포함하며, 이 멤버를 선언한 클래스의 하위클래스에서도 접근할 수 있다.
	-	public : 모든 곳에서 접근가능

-	클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private 으로 만들자.

-	public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.

	-	그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. (그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 됨)

-	클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.

	-	길이가 0이 아닌 배열은 모두 변경이 가능함
	-	이런 필드나 접근자를 제공한다면 클라이언트에서 그 배열의 내용을 수정할 수 있게 된다.
	-	해결책

		```java
		private static final Thing[] PRIVATE_VALUES = {...};
		// 방어적 복사
		public static final Thing[] values(){
		    return PRIVATE_VALUES.clone();
		}
		```

-	자바 9에서 모듈 시스템이라는 개념이 도입되면서 암묵적인 접근 수준이 추가됨.

	-	모듈은 자신이 속하는 패키지 중 공개할 것들을 선언한다. (관례상 module-info.java)
		-	protected 혹은 public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서는 접근할 수 없다.

-	책에 있는 핵심정리

	-	프로그램 요소의 접근성은 가능한 한 최소한으로 하라.
	-	꼭 필요한 것만 최소한의 public API를 설계하자.
	-	public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다. public static final 필드가 참조하는 객체가 불변인지 확인하라.

#### 아이템 16 : public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

-	이런 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못한다. (불변식을 보장할 수 없다. 외부에서 필드에 접근할 때 부수작업을 수 없다.)

	```java
	class Point{
	    public double x;
	    public double y;
	}
	```

-	필드를 모두 private 으로 바꾸고 public 접근자를 통해 데이터를 캡슐화한다.

	```java
	class Point{
	    private double x;
	    private double y;


	    public Point(double x, double y){
	        this.x = x;
	        this.y = y;
	    }


	    public double getX(){
	        return x;
	    }
	    public double getY(){
	        return y;
	    }


	    public void setX(double x){
	        this.x = x;
	    }
	    public void setY(double y){
	        this.y = y;
	    }
	}
	```

> 패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.

-	책에 있는 핵심 정리
	-	public 클래스는 절대 가변 필드를 직접 노출해서는 안된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
	-	package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을때도 있다.

#### 아이템 17 : 변경 가능성을 최소화하라

-	불변 클래스는 인스턴스의 내부 값을 수정할 수 없는 클래스다. 객체가 파괴되는 순간까지 달라지지 않는다.

-	클래스를 불변으로 만들려면 다섯 가지 규칙을 따르면 된다.

	-	객체의 상태를 변경하는 메서드를 제공하지 않는다.
	-	클래스를 확장할 수 없도록 한다 : 하위클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 상태를 막아준다.
	-	모든 필드를 final로 선언한다
	-	모든 필드를 private으로 선언한다 : 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.
	-	자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

-	불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다. 불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있다.

-	불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복으로 생성하지 않게 해주는 정적팩터리를 제공할 수 있다.

	-	정적 팩터리를 통해 여러 클라이언트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용을 줄일 수 있음.

-	불변 클래스의 단점 : 값이 다르면 반드시 독립된 객체로 만들어야한다. (성능 부하 문제)

-	자신을 상속하지 못하게 하는 쉬운 방법은 final 클래스로 선언하는 것이지만, 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 것이 더 유연한 방법이다.

	-	바깥에서 볼 수 없는 package-private 구현 클래스를 원하는 만큼 만들어 활용할 수 있다.
	-	다수의 구현 클래스를 활용한 유연성을 제공하고, 이에 더해 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다.

	```java
	public class Complex{
	    private final double re;
	    private final double im;


	    private Complex(double re, double im){
	        this.re = re;
	        this.im = im;
	    }


	    public static Complex valueOf(double re, double im){
	        return new Complex(re, im);
	    }
	}


	```

-	정리

	-	getter가 있다고해서 무조건 setter를 만들지는 말자. (클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.)
	-	불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
	-	다른 합당한 이유가 없다면 모든 필드는 private final 이어야 한다.
	-	생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
	-	확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다.
	-	java.util.concurent 패키지의 CountDownLatch 클래스를 참고해 볼 것

#### 아이템 18 : 상속보다는 컴포지션을 사용하라

-	상속은 코드를 재사용하는 강력한 수단이지만 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다.

-	확장할 목적으로 설계되었고 문서화가 잘 된 클래스라면 안전하지만 일반적인 구체 클래스를 패키지 경계를 넘어, 즉 다른 패키지의 구체클래스를 상속하는 것인 위험하다.

	-	메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
	-	상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. (상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으므로

		-	상위클래스의 메서드 재정의 시 문제발생 우려
		-	기존 클래스의 내부 구현방식에 영향

-	피해가는 방법

	-	기존 클래스를 확장하는 대신 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하는 방법
	-	기존 클래스가 새로운 클래스의 구성요소로 쓰인다고 해서 컴포지션 이라 함
	-	새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나게 됨
	-	래퍼클래스는 콜백 프레임워크와 어울리지 않는다. (콜백 때 래퍼가 아닌 내부 객체를 호출하게 됨)

	```java
	// 새로운 클래스 (래퍼클래스)
	public class InstrumentedSet<E> extends ForwardingSet<E>{
	    private int addCount = 0;


	    private InstrumentedSet(Set<E> s){
	        super(s);
	    }


	    @Override
	    public boolean add(E e){
	        addCount++;
	        return super.add(e)
	    }
	    ...
	}


	// 전달 : 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환.
	public class ForwardingSet<E> implements Set<E> {
	    private final Set<E> s;


	    public ForwardingSet(Set<E> s) {
	        this.s = s;
	    }


	    public boolean add(E e){
	        return s.add(e);
	    }


	    @Override
	    public boolean equals(Object o){
	        return s.equals(o);
	    }


	     ...
	}


	```

-	책에 있는 핵심정리

	-	상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야한다. (상위 클래스가 확장을 고려하지 않았다면 문제가 생길 수 있음)
	-	상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용할 것. 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.

#### 아이템 19 : 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

-	상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

	-	클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.

	-	널리 쓰일 클래스를 상속용으로 설계한다면 문서화한 내부 사용 패턴과 protected 메서드와 필드를 구현하면서 선택한 결정에 영환히 책임져야 함을 잘 인식해야 한다.

-	상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

	-	상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.
	-	이 때, 재정의한 메서드가 하위클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것임.

-	책에 있는 핵심정리

	-	상속용 클래스를 설계하려면 클래스 내부에서 스스로 어떻게 사용하는지 모두 문서로 남겨야하며, 일단 문서화한 것은 그 크랠스가 쓰이는 한 반드시 지켜야한다. (그렇지 않으면 하위 클래스를 오동작하게 만들 수 있음)
	-	클래스를 확장해야할 명백한 이유가 떠오르지 않는다면 상속을 금지하는 편이 나음 (클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 됨)
