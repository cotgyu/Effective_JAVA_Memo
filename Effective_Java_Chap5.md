이펙티브 자바
-------------

---

### 5장 제네릭

-	제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 된다.
	-	컴파일러는 알아서 형변환 코드를 추가해줌
	-	엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여 더 안전하고 명확한 프로그램을 만들어줌

#### 아이템 26 로 타입은 사용하지 말라

-	List< String>은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다.

-	로 타입 : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때 ( List< E> )

	> 오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.

-	로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게된다.

	```java
	// 로 타입으로 인해 런타입 오류가 발생할 때
	private final Collection stamps = ....;


	stamps.add(new Coin(...));


	for(Iterator i = stamps.iterator(); i.hasNext(); ){
	    Stamp stamp = (Stamp) i.next(); // ClassCastException !!
	    stamp.cancle();
	}


	------------------------------------------------------


	// 타입의 안정성 확보 : 이 경우 컴파일 오류가 발생한다.
	private final Collection<Stamp> stamps = ...;


	stamps.add(new Coin(...));


	for(Iterator i = stamps.iterator(); i.hasNext(); ){
	    Stamp stamp = (Stamp) i.next(); // incompatible types : Coin cannot be converted to Stamp
	    stamp.cancle();
	}


	```

-	List 와 List< Ojbect> 차이

	-	List는 제네릭이 발을 뺀 것임 (타입 안전성을 잃게됨!!)
	-	List< Object> 는 모든 타입을 허용한다는 의사를 컴파일러에 전달

-	원소의 타입을 몰라도 되는 로 타입을 쓰고 싶다면 와일드 카드 타입을 쓸 것! ( Set< ?> )

-	로 타입 예외

	-	class 리터럴에는 로 타입을 써야한다. (매개변수화 타입을 사용하지 못한다)
	-	instanceof : 런타입에는 제네릭 타입정보가 지워진다. 로 타입이든 비한정적 와일드카드 타입이든 instanceof는 똑같이 동작한다.

-	책에 있는 핵심 정리

	-	로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안된다.
	-	로 타입은 제네릭이 도입되지 전 이전 코드와 호환성을 위해 제공될 뿐이다.
	-	Set< Object>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이다.
	-	Set<?>는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다.

#### 아이템 27 비검사 경고를 제거하라

-	할 수 있는 한 모든 비검사 경고를 제거하라! 모두 제거한다면 그 코드는 타입 안전성이 보장된다. (런타입에 ClassCastException이 발생할 일이 없다.)

-	자바 7에서는 다이아몬드 연산자를 제공하는데, 이를 통해 컴파일러가 올바른 실제 타입 매개변수를 추론해준다.

	```java
	Set<Lark> exaltation = new HashSet<>();
	```

-	경고를 제거할 수는 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked") 애노테이션을 달아 경고를 숨기자

	-	이 애노테이션은 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있다. (심각한 경고를 놓칠 수 있으니 클래스전체에는 달지 말 것 !)
	-	애노테이션을 사용할 때 그 경고를 무시해도 안전한 이유를 항상 주석으로 남길 것!

-	책에 있는 핵심 정리

	-	비검사 경고는 중요하니 무시하지 말자. 런터임에 ClassCastException을 일으킬 수 있다.
	-	경고를 없앨 방법을 찾지못한다면, 그 코드가 타입 안전함을 증명하고 가능한 범위를 좁혀 @SuppressWarnings("unchecked") 애너테이션으로 경고를 숨겨라. (숨긴 이유 주석으로 남길 것)

#### 아이템 28 배열보다는 리스트를 사용하라

-	배열과 제네릭 타입에는 차이가 있다.

	-	배열 : 공변, 런타임에도 자신이 담기로한 원소의 타입을 인지하고 확인한다.
	-	제네릭 : 불공변, 타입정보가 런타임에는 소거된다.

-	책에 있는 핵심 정리

	-	배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
	-	배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다.
	-	배열에는 런타임에는 타입안전하지만 컴파일 타임에는 그렇지 않다 (제네릭은 그 반대 )
	-	둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 배열을 리스트로 대체하는 방법을 적용해보자.

#### 아이템 29 이왕이면 제네릭 타입으로 만들라

-	제네릭 타입과 메서드를 사용하는 일은 쉬운 편이지만, 제네릭타입을 새로 만드는 것은 조금 더 어렵다.

	-	그래도 알면 충분한 값어치가 있다.

-	책에서는 스택예제를 Object -> 제네릭 변환과정과 함께 오류해결방법을 소개한다.

-	책에 있는 핵심정리

	-	클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다.
	-	새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하라. (이 경우 제네릭타입으로 만들어야할 경우가 많음)
	-	기본 타입 중 제네릭이었어야하는 게 있다면 제네릭 타입으로 변경하라. (기존 클라이언트에는 아무 영향을 주지 않으면서, 새로운 사용자를 훨씬 편하게 해주는 길이다!)

#### 아이템 30 이왕이면 제네릭 메서드로 만들라

-	클래스와 마찬가지로, 메서드도 제네릭하게 만들 수 있다.
-	매개변수화 타입을 받는 정적 유틸리티메서드는 보통 제네릭이다. (Ex_ Collection의 binarySearch, sort 등)

-	책에 있는 핵심정리

	-	제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환 값을 명시적으로 형변해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다.
	-	타입과 마찬가지로, 메서드도 형변환 없이 사용할 수 있는 편이 좋으며 많은 경우 그렇게 하려면 제네릭 메서드가 되어야 한다.

#### 아이템 31 한정적 와일드카드를 사용해 API 유연성을 높이라

-	매개변수와 타입은 불공변이다.

	-	서로 다른 타입 Type1과 Type2가 있을 떄 List<Type1>은 List<Type2>의 하위타입도 상위타입도 아니다.

-	떄론 불공변 방식보다 유연한 방식이 필요할 때가 있다.

```java
public class Stack<E>{
	public Stack();
	public void push(E e);
	public E pop();
}

// 일련의 원소를 스탹에 넣는 메서드를 추가한다.
public void pushAll(Iterable<E> src){
	for(E e : src)
		push(e);
}

// Stack<Number>로 선언한 후 pushAll(intVal)을 호출하면 에러가 발생한다.
// error: incompatible types: Iterable<Integer>
Stack<Number> numberStack = new Stack<>();
Iterable<Integer> integers = ...;
numberStack.pushAll(integers);


// 이 경우 한정적 와일드카드 타입으로 대처가능하다.
// E 의 하위 타입의 Iterable
public void pushAll(Iterable<? extends E> src){
	for (E e : src)
		push(e);
}
```

-	유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라.

	-	하지만, 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없다. (타입을 정확하게 지정해야하는 상황이므로)

-	펙스(PECS) : producer-extends, consumer-super

	-	매개변수화 타입 T가 생산자라면 <? extends T>를 사용하고, 소비자라면<? super T>를 사용하라.
		-	pushAll의 src 매개변수는 Stack이 사용할 E 인스턴스를 생산함.
		-	popAll의 dst 매개변수는 Stack으로 부터 E 인스턴스를 소비함.

> 클래스 사용자가 와일드 카드 타입을 신경써야 한다면 그 API에 무슨 문제가 있을 가능성이 크다.

-	Comparable은 언제나 소비자이므로, Comparable<E>보다는 Comparable<? super E>를 사용하는 편이 낫다. (Comparator도 동일)

-	타입 매개변수와 와일드카드에는 공통되는 부분이 있어서, 메서드를 정의할 때 둘 중 어느 것을 사용해도 괜찮을 경우가 있음.

	```java
	public static <E> void swap(List<E> list, int i, int j);
	public static void swap(List<?> list, int i, int j);
	```

	-	**메서드 선언에 타입 매개변수가 한 번만 나오면 와일드 카드로 대체하라.**

-	책에 있는 핵심정리

	-	조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.
	-	PECS 공식을 기억하자.

#### 아이템 32 제네릭과 가변인수를 함께 쓸 때는 신중하라

-	가변인수는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데, 구현 방식에 허점이 있다.

	-	매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생한다.

	-	매개변수화 타입이 변수가 타입이 다른 객체를 참조하면 힙 오염이 발생한다.

-	자바7 에서 @SafeVarargs 애터테이션이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 됨. (메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치임)

-	가변 인수 메서드를 호출할 때 varargs 매개변수를 담는 제네릭 배열이 만들어지는데, 메서드가 이 배열에 아무것도 저장하지 않고 그 배열의 참조가 밖으로 노출되지 않는다면 타입안전하다.

	> varargs 매개변수 배열이 호출자로부터 그 메서드로 순수하게 인수들을 전달하는 일만한다면 그 메서드는 안전하다.

-	@SafeVarargs 애너테이션을 사용해야 할 때를 정하는 규칙

	-	제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @SafeVarargs를 달라.

-	다음의 두 조건을 만족하는 제네릭 varargs 메서드는 안전하다.

	-	varargs 매개변수 배열에 아무것도 저장하지 않는다.

	-	그 배열(혹은 복제본)을 신뢰할 수 없는 코드에 노출하지 않는다.

-	책에 있는 핵심 정리

	-	메서드에 제네릭 (혹은 매개변수화된) varargs 매개변수를 사용하고자 한다면, 먼저 그 메서드 타입 안전한지 확인한 다음 @SafeVarArgs 애너테이션을 달아 사용하는 데 불편함이 없게끔 하자.

#### 아이템 33 타입 안전 이종 컨테이너를 고려하라

-	타입 안전 이종 컨테이너 패턴 : 컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 빨 때 매개변수화한 키를 함께 제공

-	책에 있는 핵심 정리

	-	컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어있다.

	-	컨테이너 자체가 아닌 키를 타입 매개변수를 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있다.

		-	타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 한다.

		-	직접 구현한 키 타입도 쓸 수 있다.
