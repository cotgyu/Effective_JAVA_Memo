이펙티브 자바
-------------

---

### 11장 동시성

-	스레드는 여러 활동을 동시에 수행할 수 있게 해준다.

	-	하지만 동시성 프로그래밍은 단일 스레드 프로그래밍보다 어렵다. (잘못될 수 있는 일이 늘어나고, 문제를 재현하기도 어려움)

-	동시성 프로그래밍은 자바 플랫폼 자체에도 내재되어 있을 뿐 아니라, 오늘날 어디서나 쓰이는 멀티코어 프로세서의 힘을 활용하려면 필요함!

#### 아이템 78 공유 중인 가변 데이터는 동기화해 사용하라

-	synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다.

	-	많은 프로그래머가 동기화를 배타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일괄되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다.

		-	한 객체가 일관된 상태를 가지고 생성되고, 이 객체에 접근하는 메서드는 그 객체에 락을 건다.
		-	락은 건 메서드는 객체의 상태를 확인하고 필요하면 수정한다.
		-	객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화시킨다.

	-	동기화에는 중요한 기능이 하나 더 있음. 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.

		-	동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메서나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게해줌.

-	동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.

	-	공유 중인 가변 데이터를 비록 원자적으로 읽고 쓸 수 있을지라도 동기화에 실패하면 처참한 결과로 이어질 수 있다.
	-	다른 스레드를 멈추는 작업을 예시로 하면 Thread.stop 메서드는 안전하지 않아 deprecated api로 지정되었다.

	```java
	// 적절히 동기화하여 스레드 종료 예시
	public class StopThread{
	    private static boolean stopRequested;


	    private static synchronized void requestStop(){
	        stopRequested = true;
	    }


	    private static synchronized boolean stopRequested(){
	        return stopRequested;
	    }


	    public static void main(String[] args) throws InterruptedException{
	        Thread backgroundThread = new Thread(() -> {
	            int i = 0;
	            while(!stopRequested()){
	                i ++;
	            }
	        });
	        backgroundThread.start();


	        TimeUnit.SECONDS.sleep(1);
	        requestStop();
	    }
	}
	```

-	volatile 한정자 를 통해 위의 동기화를 생략할 수 있다.

	-	volatile 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게됨을 보장한다.

-	java.util.concurrent.atomic 패키지의 AtomicLong을 사용해보자.

	-	이 패키지에는 락 없이도 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨져 있다.
	-	volatile은 동기화의 두 효과 중 통신 쪽만 지원하지만 이 패키지는 원자성(배타적 실행)까지 지원한다. 성능도 동기화 버전보다 우수함.

-	위의 문제들을 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것

	-	불변 데이터만 공유하거나 아무것도 공유하지 말자
	-	가변데이터는 단일 스레드에서만 쓰자

-	책에 있는 핵심 정리

	-	여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.

		-	동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수 도 있다.
		-	공유되는 가변 데이터를 동기화하는 데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다.
		-	간헐적이나 특정 타이밍에만 발생할 수 있고, VM에 따라 현상이 달라지기도 한다.

	-	배타적 실행은 필요 없고 스레드끼리의 통신이 필요하다면 volatile 한정자만으로 동기화할 수 있다.

		-	다만 올바로 사용하기 까다롭다.
