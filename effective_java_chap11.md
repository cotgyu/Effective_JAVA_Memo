이펙티브 자바
-------------

---

### 11장 동시성

-	스레드는 여러 활동을 동시에 수행할 수 있게 해준다.

	-	하지만 동시성 프로그래밍은 단일 스레드 프로그래밍보다 어렵다. (잘못될 수 있는 일이 늘어나고, 문제를 재현하기도 어려움)

-	동시성 프로그래밍은 자바 플랫폼 자체에도 내재되어 있을 뿐 아니라, 오늘날 어디서나 쓰이는 멀티코어 프로세서의 힘을 활용하려면 필요함!

#### 아이템 78 공유 중인 가변 데이터는 동기화해 사용하라

-	synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다.

	-	많은 프로그래머가 동기화를 배타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일괄되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다.

		-	한 객체가 일관된 상태를 가지고 생성되고, 이 객체에 접근하는 메서드는 그 객체에 락을 건다.
		-	락은 건 메서드는 객체의 상태를 확인하고 필요하면 수정한다.
		-	객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화시킨다.

	-	동기화에는 중요한 기능이 하나 더 있음. 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.

		-	동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메서나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게해줌.

-	동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.

	-	공유 중인 가변 데이터를 비록 원자적으로 읽고 쓸 수 있을지라도 동기화에 실패하면 처참한 결과로 이어질 수 있다.
	-	다른 스레드를 멈추는 작업을 예시로 하면 Thread.stop 메서드는 안전하지 않아 deprecated api로 지정되었다.

	```java
	// 적절히 동기화하여 스레드 종료 예시
	public class StopThread{
	    private static boolean stopRequested;


	    private static synchronized void requestStop(){
	        stopRequested = true;
	    }


	    private static synchronized boolean stopRequested(){
	        return stopRequested;
	    }


	    public static void main(String[] args) throws InterruptedException{
	        Thread backgroundThread = new Thread(() -> {
	            int i = 0;
	            while(!stopRequested()){
	                i ++;
	            }
	        });
	        backgroundThread.start();


	        TimeUnit.SECONDS.sleep(1);
	        requestStop();
	    }
	}
	```

-	volatile 한정자 를 통해 위의 동기화를 생략할 수 있다.

	-	volatile 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게됨을 보장한다.

-	java.util.concurrent.atomic 패키지의 AtomicLong을 사용해보자.

	-	이 패키지에는 락 없이도 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨져 있다.
	-	volatile은 동기화의 두 효과 중 통신 쪽만 지원하지만 이 패키지는 원자성(배타적 실행)까지 지원한다. 성능도 동기화 버전보다 우수함.

-	위의 문제들을 피하는 가장 좋은 방법은 가변 데이터를 공유하지 않는 것

	-	불변 데이터만 공유하거나 아무것도 공유하지 말자
	-	가변데이터는 단일 스레드에서만 쓰자

-	책에 있는 핵심 정리

	-	여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.

		-	동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수 도 있다.
		-	공유되는 가변 데이터를 동기화하는 데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다.
		-	간헐적이나 특정 타이밍에만 발생할 수 있고, VM에 따라 현상이 달라지기도 한다.

	-	배타적 실행은 필요 없고 스레드끼리의 통신이 필요하다면 volatile 한정자만으로 동기화할 수 있다.

		-	다만 올바로 사용하기 까다롭다.

#### 아이템 79 과도한 동기화는 피하라

-	과도환 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.

-	응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.

	-	동기화된 영억 안에서는 재정의할 수 있는 메서드는 호출하면 안 되며, 클라이언트가 넘겨준 함수객체를 호출해서도 안된다.
	-	동기화된 영억을 포함한 클래스 관점에서는 이런 메서드는 모두 바깥에서 온 외계인이다. (그 메서드가 무슨일을 할지 모르며 통제할 수도 없다)
	-	외계인 메서드가 하는 일에 따라 동기화된 영역은 예외를 일으키거나, 교착 상태에 빠지거나 데이터를 훼손할 수 있다.

> 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.

-	락을 얻고, 공유 데이터를 검사하고, 필요하면 수정하고, 락을 놓는다.

	-	오래걸리는 작업이라면 아이템 78을 어기지 않으면서 동기화 영역 바깥으로 옮기는 방법을 찾아보자.

-	멀티코어가 일반화된 오늘날, 과도한 동기화가 초래하는 진짜 비용은 락을 얻는 데 드는 CPU시간이 아니다.

	-	경쟁하느라 낭비한 시간, 즉 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 진짜 비용이다.
	-	가상머신의 코드 최적화를 제한한다는 점도 과도한 동기화의 또 다른 숨은 비용이다.

-	가변클래스를 작성하려거든 다음 두 선택지 중 하나를 따르자.

	-	동기화를 전혀 하지 말고, 그 클래스를 동시에 사용하는 클래스가 외부에서 알아서 동기화하게 하자.
	-	동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.
		-	단, 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두번째 방법을 선택해야 한다.

-	클래스를 내부에서 동기화하기로 했다면, 락 분할, 락 스트라이핑, 비차단 동시성 제어 등 다양한 기법을 동원해 동시성을 높여줄 수 있다.

-	책에 있는 핵심 정리

	-	교착 상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자
	-	동기화 영역 안에서의 작업은 최소환으로 줄이자
	-	가변 클래스르 설계할 때는 스스로 동기화해야할 지 고민하자.
	-	멀티코어 세상인 지금은 과도한 동기화를 피하는 게 어느때보다 중요하다.
		-	합당한 이유가 있을 때만 내부에서 동기화하고, 동기화했을 지 여부를 문서에 명확히 밝히자

#### 아이템 80 스레드보다는 실행자, 태스크, 스트림을 애용하라

-	java.util.concurrent 패키지는 실행자 프레임워크(Executor Framework)라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

```java
// 작업 큐 생성
ExecutorService exec = Executors.newSingleThreadExecutor();

// 실행자에 실행할 태스크 넘기기
exec.execute(runnable);

// 실행자 종료
exe.shutdown();
```

-	실행자 서비스의 주요 기능들

	-	특정 태스트가 완료되기를 기다린다.
	-	태스크 모음 중 아무것 하나 혹은 모든 태스크가 완료되기를 기다린다.
	-	실행자 서비스가 종료하기를 기다린다
	-	완료된 태스크들의 결과를 차례로 받는다
	-	태스크를 특정 시간에 혹은 주기적으로 실행하게 한다

-	큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스를 생성하면 된다.

	-	스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수 있다.

#### 아이템 81 wait와 notify보다는 동시성 유틸리티를 애용하라

-	지금은 wait와 notify를 사용해야 할 이유가 많이 줄었다.

	-	wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.

-	java.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다.

	-	실행자 프레임워크
	-	동시성 컬렉션
	-	동기화 장치

-	동시성 컬렉션은 List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다.

	-	동기화를 각자 내부에서 수행한다.
	-	따라서 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.
	-	동시성 컬렉션에서 동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출하는 일 역시 불가능하다.
		-	그래서 여러 기본 동작을 하나의 원자적 동작으로 묶는 '상태 의존적 수정' 메서드들이 추가되었다.

-	동시성 컬렉션은 동기화한 컬렉션을 낡은 유산으로 만들어버렸다

	-	Collections.synchronizedMap 보다는 ConcurrentHashMap을 사용하는 게 훨씬 좋다. (동기화된 맵을 동시성 맵으로 교체하는 것만으로도 동시성 애플리케이션의 성능은 극적으로 개선된다.)

-	컬렉션 인터페이스 중 일부는 작업이 성공적으로 완료될 때 까지 기다리도록 확장되었다.

	-	동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해준다.

-	책에 있는 핵심 정리

	-	wait와 notify를 직접 사용하는 것을 동시성 '어셈블리 언어'로 프로그래밍 하는 것에 비유할 수 있다.
	-	반면 java.util.concurrent는 고수준 언어에 비유할 수 있다.
	-	코드를 작성한다면 wait와 notify를 쓸 이유가 거의 없다.
		-	이들을 사용하는 레거시 코드를 유지보수해야 한다면 항상 표준 관용구에에 따라 while 문 안에서 호출하도록 하자.
		-	일반적으로 notify보다는 notifyAll을 사용해야한다.
		-	혹시라도 notify를 사용한다면 응답 불가 상태에 빠지지 않도록 각별히 주의하자

#### 아이템 82 스레드 안정성 수준을 문서화하라

-	한 메서드를 여러 스레드가 동시에 호출할 때 그 메서드가 어떻게 동작하느냐는 해당 클래스와 이를 사용하는 클라이언트 사이의 중요한 계약과 같다.

	-	API 문서에서 아무런 언급도 없으면 그 클래스 사용자는 나름의 가정을 해야한다.
	-	만약 그 가정이 틀리면 클라이언트 프로그램은 동기화를 충분히 하지 못하거나 지나치게 한 상태일 것이며, 두 경우 모두 심각한 오류로 이어질 수 있다.

-	멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야한다.

-	스레드 안정성이 높은 순 목록

	-	불변 : 이 클래스의 인스턴스는 마치 상수와 같아서 외부 동기화도 필요 없다. (String, Long, BigInteger)
	-	무조건적 스레드 안전 : 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다. (AtomicLong, ConcurrentHashMap)
	-	조건부적 스레드 안전 : 무조건적 스레드 안전과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다. (Collections.synchronized 래퍼 메서드가 반환한 컬렉션들)

	-	스레드 안전하지 않음 : 이 클래스의 인스턴스는 수정될 수 있다. 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 깜사야한다. (ArrayList, HashMap 같은 기본 컬렉션)

	-	스레드 적대적 : 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다. (generateSerialNumber 메서드에서 내부 동기화를 생략할 때)

		-	이 수준의 클래스는 일반적으로 정적 데이터를 아무런 동기화 없이 수정한다.
		-	스레드 적대적으로 밝혀진 클래스나 메서드는 일반적으로 문제를 고쳐 재배포하거나 사용 자제 API로 지정한다.

-	조건부 스레드 안전한 클래스는 주의해서 문서화해야 한다.

	-	어떤 순서로 호출할 때 외부 동기화가 필요한지, 그리고 그 순서로 호출하려면 어떤 락 혹은 락들을 얻어야 하는지 알려줘야 한다.

-	클래스의 스레드 안전성은 보통 클래스의 문서화 주석에 기재하지만, 독특한 특성의 메서드라면 해당 메서드 주석에 기재하도록 하자.

-	반환 타입만으로 명확히 알 수 없는 정적 팩터리라면 자신이 반환하는 객체의 스레드 안전성을 반드시 문서화해야 한다. (Collections.synchronizedMap)

-	클래스가 외부에서 사용할 수 있는 락을 제공하면 클라이언트에서 일련의 메서드 호출을 원자적으로 수행할 수 있다.

	-	하지만 이 유연성에는 대가가 따름
	-	내부에서 처리하는 고성능 동시성 제어 메커니즘과 혼용할 수 없게 됨
	-	클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공객을 수행할 수도 있다.

-	책에 있는 핵심 정리

	-	모든 클래스가 자신의 스레드 안전성 정보를 명확히 문서화해야 한다.
	-	정확한 언어로 명확히 설명하거나 스레드 안전성 애너테이션을 사용할 수 있다.
	-	synchronized 한정자는 문서화와 관련이 없다.
	-	조건부 스레드 안전 클래스는 메서드를 어떤 순서로 호출할 떄 외부 동기화가 요구되고, 그때 어떤 락을 얻어야 하는지도 알려줘야 한다.
	-	무조건적 스레드 안전 클래스를 작성할 때는 synchronizeㅇ 메서드가 아닌 메비공개 락 객체를 사용하자.
	-	이렇게 해야 클라이언나 하위 클래스에서 동기화 메커니즘을 깨뜨리는 걸 예방할 수 있고, 필요하다면 더 다음에 더 정교한 동시성 제어 메커니즘으로 재구현할 여지가 생긴다.

#### 아이템 83 지연 초기화는 신중히 사용하라

-	지연 초기화는 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다.

	-	값이 전혀 쓰이지 않으면 초기화도 결코 일어나지 않는다.
	-	이 기법은 정적 필드와 인스턴스 필드 모두에 사용할 수 있다.
	-	주로 최적화 용도로 쓰이지만, 클래스와 인스턴스 초기화 때 발생하는 위험한 순환 문제를 해결하는 효과도 있다.

-	지연초기화는 양날의 검이다.

	-	클래스 혹은 인스턴스 생성 시의 초기화 비용은 줄지만 그 대신 지연 초기화하는 필드에 접근하는 비용은 커진다.
	-	지연 초기화하려는 필드들 중 결국 초기화가 이뤄지는 비율에 따라, 실제 초기화에 드는 비용에 따라, 초기화된 각 필드를 얼마나 빈번히 호출하느냐에 따라 지연초기화가 실제로 성능을 느려지게 할 수도 있다.

-	클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율은 낮은 반면, 그 필드를 초기화하는 비용이 크다면 지연 초기화가 제 역할을 해줄 것이다.

-	멀티스레드 환경에서는 지연 초기화를 하기가 까다롭다.

	-	지연 초기화하는 필드를 둘 이상의 스레드가 공유한다면 어떤 형태로든 반드시 동기화해야 한다. 그렇기 않으면 심각한 버그로 이어질 것이다.

-	대부분 상황에서 일반적인 초기화가 지연 초기화보다 낫다.

```java
// 일반적인 방법
private final FieldType field = computeFieldValue();

// 지연 초기화가 초기화 순환성을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하라
// 지연초기화 - synchronized 방식
private FieldType field2;

private synchronized FiledType getField(){
	if (filed2 == null){
		field2 = computeFieldValue();
	}

	return field2;
}


// 성능 떄문에 정적필드를 지연초기화 해야한다면 지연 초기화 홀더 클래스 관용구를 사용하라
// 정적 필드용 지연초기화 홀더 클래스 관용구
// getField 가 처음 호출되는 순간 FieldHolder 클래스 초기화를 촉발함
private static class FieldHolder{
	static field FieldType field3 = computeFieldValue();
}

private static FieldType getField() {
	return FieldHolder.field3;
}

// 성능 때문에 인스턴스 필드를 지연초기화해야 한다면 이중 검사 관용구를 사용하라
// 인스턴스 필드 지연초기화용 이중검사 관용구
private volatile FieldType field4;

private FieldType getField(){
	FieldType result = field;

	if(result != null){
		return result;
	}

	synchronized(this){
		if (field == null){
			field = computeFieldValue();
		}
		return field;
	}
}
```

-	책에 있는 핵심 정리
	-	대부분의 필드는 지연시키지 말고 곧바로 초기화해야 한다.
	-	성능 떄문에 혹은 위험한 초기화 순환을 막기 위해 꼭 지연 초기화를 써야 한다면 올바른 지연 초기화 기법을 사용하자.
	-	인스턴스 필드에는 이중검사 관용구를, 정적 필드에는 지연 초기화 홀더 클래스 관용구를 사용하자. 반복해 초기화해도 괜찮은 인스턴스 필드에는 단일검사 관용구도 고려 대상이다.

#### 아이템 84 프로그램의 동작을 스레드 스케줄러에 기대지 말라

-	여러 스레드가 실행 중이면 운영체제의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할지 정한다.

	-	잘 작성된 프로그램이라면 운영체제의 스레드 스케줄러 정책에 좌지우지돼서는 안된다.
	-	정확성이나 성능이 스레드 스케줄러에 따라 지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

-	견고하고 빠릿하고 이식성 좋은 프로그램을 작성하는 가장 좋은 방법은 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다.

	-	실행 가능한 스레드 수를 적게 유지하는 주요 기법은 각 스레드가 무언가 유용한 작업을 완료한 후에는 다음 일거리가 생길 때까지 대기하도록 하는 것이다.
	-	스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안된다.

-	책에 있는 핵심 정리

	-	프로그램의 동작을 스레드 스케줄러에 기대지 말자.
	-	견고성과 이식성을 모두 해치는 행위다.
		-	같은 이유로 Thread.yield와 스레드 우선순위에 의존해서도 안된다.
		-	이 기능들은 스레드 스케줄러에 제공하는 힌트일 뿐이다.
		-	스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓰일 수 있지만, 간신히 동작하는 프로그램을 고치는 용도로 사용해서는 절대 안된다.
